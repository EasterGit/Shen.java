"**********************************************************************************
*                           The License						                                      *
* 										                                                                  *
* The user is free to produce commercial applications with the software, to 	          *
* distribute these applications in source or binary  form, and to charge monies         *
* for them as he sees fit and in concordance with the laws of the land subject 	        *
* to the following license.							                                                *
*										                                                                    * 
* 1. The license applies to all the software and all derived software and 	            *
*    must appear on such.							                                                  *
*										                                                                    *
* 2. It is illegal to distribute the software without this license attached	            *
*    to it and use of the software implies agreement with the license as such.          *
*    It is illegal for anyone who is not the copyright holder to tamper with 	          *
*    or change the license.							                                                *
*										                                                                    *
* 3. Neither the names of Lambda Associates or the copyright holder may be used         *
*    to endorse or promote products built using the software without specific 	        *
*    prior written permission from the copyright holder.		                            *
*										                                                                    *
* 4. That possession of this license does not confer on the copyright holder 	          *
*    any special contractual obligation towards the user. That in no event 	            * 
*    shall the copyright holder be liable for any direct, indirect, incidental,        *   
*    special, exemplary or consequential damages (including but not limited             *
*    to procurement of substitute goods or services, loss of use, data, 	              * 
*    interruption), however caused and on any theory of liability, whether in	          * 
*    contract, strict liability or tort (including negligence) arising in any         	*
*    way out of the use of the software, even if advised of the possibility of         	*
*    such damage.						                                                        		* 
*										                                                                    *
* 5. It is permitted for the user to change the software, for the purpose of 	          *
*    improving performance, correcting an error, or porting to a new platform, 	        *
*    and distribute the derived version of Shen provided the resulting program 	        *
*    conforms in all respects to the Shen standard and is issued under that             * 
*    title. The user must make it clear with his distribution that he/she is 	          *
*    the author of the changes and what these changes are and why. 		                  *
*										                                                                    *
* 6. Derived versions of this software in whatever form are subject to the same         *
*    restrictions. In particular it is not permitted to make derived copies of          *
*    this software which do not conform to the Shen standard or appear under a          *
*    different title.								                                                    *
*										                                                                    *
*    It is permitted to distribute versions of Shen which incorporate libraries,        *
*    graphics or other facilities which are not part of the Shen standard.	            *
*										                                                                    *
* For an explication of this license see www.shenlanguage.org/license.htm which         *
* explains this license in full.                                                        *
*				 						                                                                    *
*****************************************************************************************
"(defun shen.typecheck (V2829 V2830) (let Curry (shen.curry V2829) (let ProcessN (shen.start-new-prolog-process) (let Type (shen.insert-prolog-variables (shen.demodulate (shen.curry-type V2830)) ProcessN) (let Continuation (freeze (return Type ProcessN shen.void)) (shen.t* (cons Curry (cons : (cons Type ()))) () ProcessN Continuation))))))

(defun shen.curry (V2831) (cond ((and (cons? V2831) (shen.special? (hd V2831))) (cons (hd V2831) (map shen.curry (tl V2831)))) ((and (cons? V2831) (and (cons? (tl V2831)) (shen.extraspecial? (hd V2831)))) V2831) ((and (cons? V2831) (and (cons? (tl V2831)) (cons? (tl (tl V2831))))) (shen.curry (cons (cons (hd V2831) (cons (hd (tl V2831)) ())) (tl (tl V2831))))) ((and (cons? V2831) (and (cons? (tl V2831)) (= () (tl (tl V2831))))) (cons (shen.curry (hd V2831)) (cons (shen.curry (hd (tl V2831))) ()))) (true V2831)))

(defun shen.special? (V2832) (element? V2832 (value shen.*special*)))

(defun shen.extraspecial? (V2833) (element? V2833 (value shen.*extraspecial*)))

(defun shen.t* (V2834 V2835 V2836 V2837) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (let Error (shen.newpv V2836) (do (shen.incinfs) (fwhen (shen.maxinfexceeded?) V2836 (freeze (bind Error (shen.errormaxinfs) V2836 V2837))))) (if (= Case false) (let Case (let V2823 (shen.lazyderef V2834 V2836) (if (= fail V2823) (do (shen.incinfs) (cut Throwcontrol V2836 (freeze (shen.prolog-failure V2836 V2837)))) false)) (if (= Case false) (let Case (let V2824 (shen.lazyderef V2834 V2836) (if (cons? V2824) (let X (hd V2824) (let V2825 (shen.lazyderef (tl V2824) V2836) (if (cons? V2825) (let V2826 (shen.lazyderef (hd V2825) V2836) (if (= : V2826) (let V2827 (shen.lazyderef (tl V2825) V2836) (if (cons? V2827) (let A (hd V2827) (let V2828 (shen.lazyderef (tl V2827) V2836) (if (= () V2828) (do (shen.incinfs) (fwhen (shen.type-theory-enabled?) V2836 (freeze (cut Throwcontrol V2836 (freeze (shen.th* X A V2835 V2836 V2837)))))) false))) false)) false)) false))) false)) (if (= Case false) (let Datatypes (shen.newpv V2836) (do (shen.incinfs) (shen.show V2834 V2835 V2836 (freeze (bind Datatypes (value shen.*datatypes*) V2836 (freeze (shen.udefs* V2834 V2835 Datatypes V2836 V2837))))))) Case)) Case)) Case)))))

(defun shen.type-theory-enabled? () (value shen.*shen-type-theory-enabled?*))

(defun enable-type-theory (V2842) (cond ((= + V2842) (set shen.*shen-type-theory-enabled?* true)) ((= - V2842) (set shen.*shen-type-theory-enabled?* false)) (true (simple-error "enable-type-theory expects a + or a -
"))))

(defun shen.prolog-failure (V2851 V2852) false)

(defun shen.maxinfexceeded? () (> (inferences) (value shen.*maxinferences*)))

(defun shen.errormaxinfs () (simple-error "maximum inferences exceeded~%"))

(defun shen.udefs* (V2853 V2854 V2855 V2856 V2857) (let Case (let V2819 (shen.lazyderef V2855 V2856) (if (cons? V2819) (let D (hd V2819) (do (shen.incinfs) (call (cons D (cons V2853 (cons V2854 ()))) V2856 V2857))) false)) (if (= Case false) (let V2820 (shen.lazyderef V2855 V2856) (if (cons? V2820) (let Ds (tl V2820) (do (shen.incinfs) (shen.udefs* V2853 V2854 Ds V2856 V2857))) false)) Case)))

(defun shen.th* (V2858 V2859 V2860 V2861 V2862) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (do (shen.incinfs) (shen.show (cons V2858 (cons : (cons V2859 ()))) V2860 V2861 (freeze (fwhen false V2861 V2862)))) (if (= Case false) (let Case (let F (shen.newpv V2861) (do (shen.incinfs) (fwhen (shen.typedf? (shen.lazyderef V2858 V2861)) V2861 (freeze (bind F (shen.sigf (shen.lazyderef V2858 V2861)) V2861 (freeze (call (cons F (cons V2859 ())) V2861 V2862))))))) (if (= Case false) (let Case (do (shen.incinfs) (shen.base V2858 V2859 V2861 V2862)) (if (= Case false) (let Case (do (shen.incinfs) (shen.by_hypothesis V2858 V2859 V2860 V2861 V2862)) (if (= Case false) (let Case (let V2697 (shen.lazyderef V2858 V2861) (if (cons? V2697) (let F (hd V2697) (let V2698 (shen.lazyderef (tl V2697) V2861) (if (= () V2698) (do (shen.incinfs) (shen.th* F (cons --> (cons V2859 ())) V2860 V2861 V2862)) false))) false)) (if (= Case false) (let Case (let V2699 (shen.lazyderef V2858 V2861) (if (cons? V2699) (let F (hd V2699) (let V2700 (shen.lazyderef (tl V2699) V2861) (if (cons? V2700) (let X (hd V2700) (let V2701 (shen.lazyderef (tl V2700) V2861) (if (= () V2701) (let B (shen.newpv V2861) (do (shen.incinfs) (shen.th* F (cons B (cons --> (cons V2859 ()))) V2860 V2861 (freeze (shen.th* X B V2860 V2861 V2862))))) false))) false))) false)) (if (= Case false) (let Case (let V2702 (shen.lazyderef V2858 V2861) (if (cons? V2702) (let V2703 (shen.lazyderef (hd V2702) V2861) (if (= cons V2703) (let V2704 (shen.lazyderef (tl V2702) V2861) (if (cons? V2704) (let X (hd V2704) (let V2705 (shen.lazyderef (tl V2704) V2861) (if (cons? V2705) (let Y (hd V2705) (let V2706 (shen.lazyderef (tl V2705) V2861) (if (= () V2706) (let V2707 (shen.lazyderef V2859 V2861) (if (cons? V2707) (let V2708 (shen.lazyderef (hd V2707) V2861) (if (= list V2708) (let V2709 (shen.lazyderef (tl V2707) V2861) (if (cons? V2709) (let A (hd V2709) (let V2710 (shen.lazyderef (tl V2709) V2861) (if (= () V2710) (do (shen.incinfs) (shen.th* X A V2860 V2861 (freeze (shen.th* Y (cons list (cons A ())) V2860 V2861 V2862)))) (if (shen.pvar? V2710) (do (shen.bindv V2710 () V2861) (let Result (do (shen.incinfs) (shen.th* X A V2860 V2861 (freeze (shen.th* Y (cons list (cons A ())) V2860 V2861 V2862)))) (do (shen.unbindv V2710 V2861) Result))) false)))) (if (shen.pvar? V2709) (let A (shen.newpv V2861) (do (shen.bindv V2709 (cons A ()) V2861) (let Result (do (shen.incinfs) (shen.th* X A V2860 V2861 (freeze (shen.th* Y (cons list (cons A ())) V2860 V2861 V2862)))) (do (shen.unbindv V2709 V2861) Result)))) false))) (if (shen.pvar? V2708) (do (shen.bindv V2708 list V2861) (let Result (let V2711 (shen.lazyderef (tl V2707) V2861) (if (cons? V2711) (let A (hd V2711) (let V2712 (shen.lazyderef (tl V2711) V2861) (if (= () V2712) (do (shen.incinfs) (shen.th* X A V2860 V2861 (freeze (shen.th* Y (cons list (cons A ())) V2860 V2861 V2862)))) (if (shen.pvar? V2712) (do (shen.bindv V2712 () V2861) (let Result (do (shen.incinfs) (shen.th* X A V2860 V2861 (freeze (shen.th* Y (cons list (cons A ())) V2860 V2861 V2862)))) (do (shen.unbindv V2712 V2861) Result))) false)))) (if (shen.pvar? V2711) (let A (shen.newpv V2861) (do (shen.bindv V2711 (cons A ()) V2861) (let Result (do (shen.incinfs) (shen.th* X A V2860 V2861 (freeze (shen.th* Y (cons list (cons A ())) V2860 V2861 V2862)))) (do (shen.unbindv V2711 V2861) Result)))) false))) (do (shen.unbindv V2708 V2861) Result))) false))) (if (shen.pvar? V2707) (let A (shen.newpv V2861) (do (shen.bindv V2707 (cons list (cons A ())) V2861) (let Result (do (shen.incinfs) (shen.th* X A V2860 V2861 (freeze (shen.th* Y (cons list (cons A ())) V2860 V2861 V2862)))) (do (shen.unbindv V2707 V2861) Result)))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V2713 (shen.lazyderef V2858 V2861) (if (cons? V2713) (let V2714 (shen.lazyderef (hd V2713) V2861) (if (= @p V2714) (let V2715 (shen.lazyderef (tl V2713) V2861) (if (cons? V2715) (let X (hd V2715) (let V2716 (shen.lazyderef (tl V2715) V2861) (if (cons? V2716) (let Y (hd V2716) (let V2717 (shen.lazyderef (tl V2716) V2861) (if (= () V2717) (let V2718 (shen.lazyderef V2859 V2861) (if (cons? V2718) (let A (hd V2718) (let V2719 (shen.lazyderef (tl V2718) V2861) (if (cons? V2719) (let V2720 (shen.lazyderef (hd V2719) V2861) (if (= * V2720) (let V2721 (shen.lazyderef (tl V2719) V2861) (if (cons? V2721) (let B (hd V2721) (let V2722 (shen.lazyderef (tl V2721) V2861) (if (= () V2722) (do (shen.incinfs) (shen.th* X A V2860 V2861 (freeze (shen.th* Y B V2860 V2861 V2862)))) (if (shen.pvar? V2722) (do (shen.bindv V2722 () V2861) (let Result (do (shen.incinfs) (shen.th* X A V2860 V2861 (freeze (shen.th* Y B V2860 V2861 V2862)))) (do (shen.unbindv V2722 V2861) Result))) false)))) (if (shen.pvar? V2721) (let B (shen.newpv V2861) (do (shen.bindv V2721 (cons B ()) V2861) (let Result (do (shen.incinfs) (shen.th* X A V2860 V2861 (freeze (shen.th* Y B V2860 V2861 V2862)))) (do (shen.unbindv V2721 V2861) Result)))) false))) (if (shen.pvar? V2720) (do (shen.bindv V2720 * V2861) (let Result (let V2723 (shen.lazyderef (tl V2719) V2861) (if (cons? V2723) (let B (hd V2723) (let V2724 (shen.lazyderef (tl V2723) V2861) (if (= () V2724) (do (shen.incinfs) (shen.th* X A V2860 V2861 (freeze (shen.th* Y B V2860 V2861 V2862)))) (if (shen.pvar? V2724) (do (shen.bindv V2724 () V2861) (let Result (do (shen.incinfs) (shen.th* X A V2860 V2861 (freeze (shen.th* Y B V2860 V2861 V2862)))) (do (shen.unbindv V2724 V2861) Result))) false)))) (if (shen.pvar? V2723) (let B (shen.newpv V2861) (do (shen.bindv V2723 (cons B ()) V2861) (let Result (do (shen.incinfs) (shen.th* X A V2860 V2861 (freeze (shen.th* Y B V2860 V2861 V2862)))) (do (shen.unbindv V2723 V2861) Result)))) false))) (do (shen.unbindv V2720 V2861) Result))) false))) (if (shen.pvar? V2719) (let B (shen.newpv V2861) (do (shen.bindv V2719 (cons * (cons B ())) V2861) (let Result (do (shen.incinfs) (shen.th* X A V2860 V2861 (freeze (shen.th* Y B V2860 V2861 V2862)))) (do (shen.unbindv V2719 V2861) Result)))) false)))) (if (shen.pvar? V2718) (let A (shen.newpv V2861) (let B (shen.newpv V2861) (do (shen.bindv V2718 (cons A (cons * (cons B ()))) V2861) (let Result (do (shen.incinfs) (shen.th* X A V2860 V2861 (freeze (shen.th* Y B V2860 V2861 V2862)))) (do (shen.unbindv V2718 V2861) Result))))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V2725 (shen.lazyderef V2858 V2861) (if (cons? V2725) (let V2726 (shen.lazyderef (hd V2725) V2861) (if (= @v V2726) (let V2727 (shen.lazyderef (tl V2725) V2861) (if (cons? V2727) (let X (hd V2727) (let V2728 (shen.lazyderef (tl V2727) V2861) (if (cons? V2728) (let Y (hd V2728) (let V2729 (shen.lazyderef (tl V2728) V2861) (if (= () V2729) (let V2730 (shen.lazyderef V2859 V2861) (if (cons? V2730) (let V2731 (shen.lazyderef (hd V2730) V2861) (if (= vector V2731) (let V2732 (shen.lazyderef (tl V2730) V2861) (if (cons? V2732) (let A (hd V2732) (let V2733 (shen.lazyderef (tl V2732) V2861) (if (= () V2733) (do (shen.incinfs) (shen.th* X A V2860 V2861 (freeze (shen.th* Y (cons vector (cons A ())) V2860 V2861 V2862)))) (if (shen.pvar? V2733) (do (shen.bindv V2733 () V2861) (let Result (do (shen.incinfs) (shen.th* X A V2860 V2861 (freeze (shen.th* Y (cons vector (cons A ())) V2860 V2861 V2862)))) (do (shen.unbindv V2733 V2861) Result))) false)))) (if (shen.pvar? V2732) (let A (shen.newpv V2861) (do (shen.bindv V2732 (cons A ()) V2861) (let Result (do (shen.incinfs) (shen.th* X A V2860 V2861 (freeze (shen.th* Y (cons vector (cons A ())) V2860 V2861 V2862)))) (do (shen.unbindv V2732 V2861) Result)))) false))) (if (shen.pvar? V2731) (do (shen.bindv V2731 vector V2861) (let Result (let V2734 (shen.lazyderef (tl V2730) V2861) (if (cons? V2734) (let A (hd V2734) (let V2735 (shen.lazyderef (tl V2734) V2861) (if (= () V2735) (do (shen.incinfs) (shen.th* X A V2860 V2861 (freeze (shen.th* Y (cons vector (cons A ())) V2860 V2861 V2862)))) (if (shen.pvar? V2735) (do (shen.bindv V2735 () V2861) (let Result (do (shen.incinfs) (shen.th* X A V2860 V2861 (freeze (shen.th* Y (cons vector (cons A ())) V2860 V2861 V2862)))) (do (shen.unbindv V2735 V2861) Result))) false)))) (if (shen.pvar? V2734) (let A (shen.newpv V2861) (do (shen.bindv V2734 (cons A ()) V2861) (let Result (do (shen.incinfs) (shen.th* X A V2860 V2861 (freeze (shen.th* Y (cons vector (cons A ())) V2860 V2861 V2862)))) (do (shen.unbindv V2734 V2861) Result)))) false))) (do (shen.unbindv V2731 V2861) Result))) false))) (if (shen.pvar? V2730) (let A (shen.newpv V2861) (do (shen.bindv V2730 (cons vector (cons A ())) V2861) (let Result (do (shen.incinfs) (shen.th* X A V2860 V2861 (freeze (shen.th* Y (cons vector (cons A ())) V2860 V2861 V2862)))) (do (shen.unbindv V2730 V2861) Result)))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V2736 (shen.lazyderef V2858 V2861) (if (cons? V2736) (let V2737 (shen.lazyderef (hd V2736) V2861) (if (= @s V2737) (let V2738 (shen.lazyderef (tl V2736) V2861) (if (cons? V2738) (let X (hd V2738) (let V2739 (shen.lazyderef (tl V2738) V2861) (if (cons? V2739) (let Y (hd V2739) (let V2740 (shen.lazyderef (tl V2739) V2861) (if (= () V2740) (let V2741 (shen.lazyderef V2859 V2861) (if (= string V2741) (do (shen.incinfs) (shen.th* X string V2860 V2861 (freeze (shen.th* Y string V2860 V2861 V2862)))) (if (shen.pvar? V2741) (do (shen.bindv V2741 string V2861) (let Result (do (shen.incinfs) (shen.th* X string V2860 V2861 (freeze (shen.th* Y string V2860 V2861 V2862)))) (do (shen.unbindv V2741 V2861) Result))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V2742 (shen.lazyderef V2858 V2861) (if (cons? V2742) (let V2743 (shen.lazyderef (hd V2742) V2861) (if (= lambda V2743) (let V2744 (shen.lazyderef (tl V2742) V2861) (if (cons? V2744) (let X (hd V2744) (let V2745 (shen.lazyderef (tl V2744) V2861) (if (cons? V2745) (let Y (hd V2745) (let V2746 (shen.lazyderef (tl V2745) V2861) (if (= () V2746) (let V2747 (shen.lazyderef V2859 V2861) (if (cons? V2747) (let A (hd V2747) (let V2748 (shen.lazyderef (tl V2747) V2861) (if (cons? V2748) (let V2749 (shen.lazyderef (hd V2748) V2861) (if (= --> V2749) (let V2750 (shen.lazyderef (tl V2748) V2861) (if (cons? V2750) (let B (hd V2750) (let V2751 (shen.lazyderef (tl V2750) V2861) (if (= () V2751) (let Z (shen.newpv V2861) (let X&& (shen.newpv V2861) (do (shen.incinfs) (cut Throwcontrol V2861 (freeze (bind X&& (shen.placeholder) V2861 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V2861) (shen.lazyderef X V2861) (shen.lazyderef Y V2861)) V2861 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V2860) V2861 V2862)))))))))) (if (shen.pvar? V2751) (do (shen.bindv V2751 () V2861) (let Result (let Z (shen.newpv V2861) (let X&& (shen.newpv V2861) (do (shen.incinfs) (cut Throwcontrol V2861 (freeze (bind X&& (shen.placeholder) V2861 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V2861) (shen.lazyderef X V2861) (shen.lazyderef Y V2861)) V2861 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V2860) V2861 V2862)))))))))) (do (shen.unbindv V2751 V2861) Result))) false)))) (if (shen.pvar? V2750) (let B (shen.newpv V2861) (do (shen.bindv V2750 (cons B ()) V2861) (let Result (let Z (shen.newpv V2861) (let X&& (shen.newpv V2861) (do (shen.incinfs) (cut Throwcontrol V2861 (freeze (bind X&& (shen.placeholder) V2861 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V2861) (shen.lazyderef X V2861) (shen.lazyderef Y V2861)) V2861 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V2860) V2861 V2862)))))))))) (do (shen.unbindv V2750 V2861) Result)))) false))) (if (shen.pvar? V2749) (do (shen.bindv V2749 --> V2861) (let Result (let V2752 (shen.lazyderef (tl V2748) V2861) (if (cons? V2752) (let B (hd V2752) (let V2753 (shen.lazyderef (tl V2752) V2861) (if (= () V2753) (let Z (shen.newpv V2861) (let X&& (shen.newpv V2861) (do (shen.incinfs) (cut Throwcontrol V2861 (freeze (bind X&& (shen.placeholder) V2861 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V2861) (shen.lazyderef X V2861) (shen.lazyderef Y V2861)) V2861 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V2860) V2861 V2862)))))))))) (if (shen.pvar? V2753) (do (shen.bindv V2753 () V2861) (let Result (let Z (shen.newpv V2861) (let X&& (shen.newpv V2861) (do (shen.incinfs) (cut Throwcontrol V2861 (freeze (bind X&& (shen.placeholder) V2861 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V2861) (shen.lazyderef X V2861) (shen.lazyderef Y V2861)) V2861 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V2860) V2861 V2862)))))))))) (do (shen.unbindv V2753 V2861) Result))) false)))) (if (shen.pvar? V2752) (let B (shen.newpv V2861) (do (shen.bindv V2752 (cons B ()) V2861) (let Result (let Z (shen.newpv V2861) (let X&& (shen.newpv V2861) (do (shen.incinfs) (cut Throwcontrol V2861 (freeze (bind X&& (shen.placeholder) V2861 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V2861) (shen.lazyderef X V2861) (shen.lazyderef Y V2861)) V2861 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V2860) V2861 V2862)))))))))) (do (shen.unbindv V2752 V2861) Result)))) false))) (do (shen.unbindv V2749 V2861) Result))) false))) (if (shen.pvar? V2748) (let B (shen.newpv V2861) (do (shen.bindv V2748 (cons --> (cons B ())) V2861) (let Result (let Z (shen.newpv V2861) (let X&& (shen.newpv V2861) (do (shen.incinfs) (cut Throwcontrol V2861 (freeze (bind X&& (shen.placeholder) V2861 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V2861) (shen.lazyderef X V2861) (shen.lazyderef Y V2861)) V2861 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V2860) V2861 V2862)))))))))) (do (shen.unbindv V2748 V2861) Result)))) false)))) (if (shen.pvar? V2747) (let A (shen.newpv V2861) (let B (shen.newpv V2861) (do (shen.bindv V2747 (cons A (cons --> (cons B ()))) V2861) (let Result (let Z (shen.newpv V2861) (let X&& (shen.newpv V2861) (do (shen.incinfs) (cut Throwcontrol V2861 (freeze (bind X&& (shen.placeholder) V2861 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V2861) (shen.lazyderef X V2861) (shen.lazyderef Y V2861)) V2861 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V2860) V2861 V2862)))))))))) (do (shen.unbindv V2747 V2861) Result))))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V2754 (shen.lazyderef V2858 V2861) (if (cons? V2754) (let V2755 (shen.lazyderef (hd V2754) V2861) (if (= let V2755) (let V2756 (shen.lazyderef (tl V2754) V2861) (if (cons? V2756) (let X (hd V2756) (let V2757 (shen.lazyderef (tl V2756) V2861) (if (cons? V2757) (let Y (hd V2757) (let V2758 (shen.lazyderef (tl V2757) V2861) (if (cons? V2758) (let Z (hd V2758) (let V2759 (shen.lazyderef (tl V2758) V2861) (if (= () V2759) (let W (shen.newpv V2861) (let X&& (shen.newpv V2861) (let B (shen.newpv V2861) (do (shen.incinfs) (cut Throwcontrol V2861 (freeze (shen.th* Y B V2860 V2861 (freeze (bind X&& (shen.placeholder) V2861 (freeze (bind W (shen.ebr (shen.lazyderef X&& V2861) (shen.lazyderef X V2861) (shen.lazyderef Z V2861)) V2861 (freeze (shen.th* W V2859 (cons (cons X&& (cons : (cons B ()))) V2860) V2861 V2862))))))))))))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V2760 (shen.lazyderef V2858 V2861) (if (cons? V2760) (let V2761 (shen.lazyderef (hd V2760) V2861) (if (= open V2761) (let V2762 (shen.lazyderef (tl V2760) V2861) (if (cons? V2762) (let FileName (hd V2762) (let V2763 (shen.lazyderef (tl V2762) V2861) (if (cons? V2763) (let Direction2693 (hd V2763) (let V2764 (shen.lazyderef (tl V2763) V2861) (if (= () V2764) (let V2765 (shen.lazyderef V2859 V2861) (if (cons? V2765) (let V2766 (shen.lazyderef (hd V2765) V2861) (if (= stream V2766) (let V2767 (shen.lazyderef (tl V2765) V2861) (if (cons? V2767) (let Direction (hd V2767) (let V2768 (shen.lazyderef (tl V2767) V2861) (if (= () V2768) (do (shen.incinfs) (unify! Direction Direction2693 V2861 (freeze (cut Throwcontrol V2861 (freeze (shen.th* FileName string V2860 V2861 V2862)))))) (if (shen.pvar? V2768) (do (shen.bindv V2768 () V2861) (let Result (do (shen.incinfs) (unify! Direction Direction2693 V2861 (freeze (cut Throwcontrol V2861 (freeze (shen.th* FileName string V2860 V2861 V2862)))))) (do (shen.unbindv V2768 V2861) Result))) false)))) (if (shen.pvar? V2767) (let Direction (shen.newpv V2861) (do (shen.bindv V2767 (cons Direction ()) V2861) (let Result (do (shen.incinfs) (unify! Direction Direction2693 V2861 (freeze (cut Throwcontrol V2861 (freeze (shen.th* FileName string V2860 V2861 V2862)))))) (do (shen.unbindv V2767 V2861) Result)))) false))) (if (shen.pvar? V2766) (do (shen.bindv V2766 stream V2861) (let Result (let V2769 (shen.lazyderef (tl V2765) V2861) (if (cons? V2769) (let Direction (hd V2769) (let V2770 (shen.lazyderef (tl V2769) V2861) (if (= () V2770) (do (shen.incinfs) (unify! Direction Direction2693 V2861 (freeze (cut Throwcontrol V2861 (freeze (shen.th* FileName string V2860 V2861 V2862)))))) (if (shen.pvar? V2770) (do (shen.bindv V2770 () V2861) (let Result (do (shen.incinfs) (unify! Direction Direction2693 V2861 (freeze (cut Throwcontrol V2861 (freeze (shen.th* FileName string V2860 V2861 V2862)))))) (do (shen.unbindv V2770 V2861) Result))) false)))) (if (shen.pvar? V2769) (let Direction (shen.newpv V2861) (do (shen.bindv V2769 (cons Direction ()) V2861) (let Result (do (shen.incinfs) (unify! Direction Direction2693 V2861 (freeze (cut Throwcontrol V2861 (freeze (shen.th* FileName string V2860 V2861 V2862)))))) (do (shen.unbindv V2769 V2861) Result)))) false))) (do (shen.unbindv V2766 V2861) Result))) false))) (if (shen.pvar? V2765) (let Direction (shen.newpv V2861) (do (shen.bindv V2765 (cons stream (cons Direction ())) V2861) (let Result (do (shen.incinfs) (unify! Direction Direction2693 V2861 (freeze (cut Throwcontrol V2861 (freeze (shen.th* FileName string V2860 V2861 V2862)))))) (do (shen.unbindv V2765 V2861) Result)))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V2771 (shen.lazyderef V2858 V2861) (if (cons? V2771) (let V2772 (shen.lazyderef (hd V2771) V2861) (if (= type V2772) (let V2773 (shen.lazyderef (tl V2771) V2861) (if (cons? V2773) (let X (hd V2773) (let V2774 (shen.lazyderef (tl V2773) V2861) (if (cons? V2774) (let A (hd V2774) (let V2775 (shen.lazyderef (tl V2774) V2861) (if (= () V2775) (do (shen.incinfs) (cut Throwcontrol V2861 (freeze (unify A V2859 V2861 (freeze (shen.th* X A V2860 V2861 V2862)))))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V2776 (shen.lazyderef V2858 V2861) (if (cons? V2776) (let V2777 (shen.lazyderef (hd V2776) V2861) (if (= input+ V2777) (let V2778 (shen.lazyderef (tl V2776) V2861) (if (cons? V2778) (let A (hd V2778) (let V2779 (shen.lazyderef (tl V2778) V2861) (if (cons? V2779) (let Stream (hd V2779) (let V2780 (shen.lazyderef (tl V2779) V2861) (if (= () V2780) (let C (shen.newpv V2861) (do (shen.incinfs) (bind C (shen.demodulate (shen.lazyderef A V2861)) V2861 (freeze (unify V2859 C V2861 (freeze (shen.th* Stream (cons stream (cons in ())) V2860 V2861 V2862))))))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V2781 (shen.lazyderef V2858 V2861) (if (cons? V2781) (let V2782 (shen.lazyderef (hd V2781) V2861) (if (= read+ V2782) (let V2783 (shen.lazyderef (tl V2781) V2861) (if (cons? V2783) (let V2784 (shen.lazyderef (hd V2783) V2861) (if (= : V2784) (let V2785 (shen.lazyderef (tl V2783) V2861) (if (cons? V2785) (let A (hd V2785) (let V2786 (shen.lazyderef (tl V2785) V2861) (if (cons? V2786) (let Stream (hd V2786) (let V2787 (shen.lazyderef (tl V2786) V2861) (if (= () V2787) (let C (shen.newpv V2861) (do (shen.incinfs) (bind C (shen.demodulate (shen.lazyderef A V2861)) V2861 (freeze (unify V2859 C V2861 (freeze (shen.th* Stream (cons stream (cons in ())) V2860 V2861 V2862))))))) false))) false))) false)) false)) false)) false)) false)) (if (= Case false) (let Case (let V2788 (shen.lazyderef V2858 V2861) (if (cons? V2788) (let V2789 (shen.lazyderef (hd V2788) V2861) (if (= set V2789) (let V2790 (shen.lazyderef (tl V2788) V2861) (if (cons? V2790) (let Var (hd V2790) (let V2791 (shen.lazyderef (tl V2790) V2861) (if (cons? V2791) (let Val (hd V2791) (let V2792 (shen.lazyderef (tl V2791) V2861) (if (= () V2792) (do (shen.incinfs) (cut Throwcontrol V2861 (freeze (shen.th* Var symbol V2860 V2861 (freeze (cut Throwcontrol V2861 (freeze (shen.th* (cons value (cons Var ())) V2859 V2860 V2861 (freeze (shen.th* Val V2859 V2860 V2861 V2862)))))))))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V2793 (shen.lazyderef V2858 V2861) (if (cons? V2793) (let V2794 (shen.lazyderef (hd V2793) V2861) (if (= shen.<-sem V2794) (let V2795 (shen.lazyderef (tl V2793) V2861) (if (cons? V2795) (let F (hd V2795) (let V2796 (shen.lazyderef (tl V2795) V2861) (if (= () V2796) (let A (shen.newpv V2861) (let F&& (shen.newpv V2861) (let B (shen.newpv V2861) (do (shen.incinfs) (cut Throwcontrol V2861 (freeze (shen.th* F (cons A (cons ==> (cons B ()))) V2860 V2861 (freeze (cut Throwcontrol V2861 (freeze (bind F&& (concat && (shen.lazyderef F V2861)) V2861 (freeze (cut Throwcontrol V2861 (freeze (shen.th* F&& V2859 (cons (cons F&& (cons : (cons B ()))) V2860) V2861 V2862))))))))))))))) false))) false)) false)) false)) (if (= Case false) (let Case (let V2797 (shen.lazyderef V2858 V2861) (if (cons? V2797) (let V2798 (shen.lazyderef (hd V2797) V2861) (if (= fail V2798) (let V2799 (shen.lazyderef (tl V2797) V2861) (if (= () V2799) (let V2800 (shen.lazyderef V2859 V2861) (if (= symbol V2800) (do (shen.incinfs) (thaw V2862)) (if (shen.pvar? V2800) (do (shen.bindv V2800 symbol V2861) (let Result (do (shen.incinfs) (thaw V2862)) (do (shen.unbindv V2800 V2861) Result))) false))) false)) false)) false)) (if (= Case false) (let Case (let NewHyp (shen.newpv V2861) (do (shen.incinfs) (shen.t*-hyps V2860 NewHyp V2861 (freeze (shen.th* V2858 V2859 NewHyp V2861 V2862))))) (if (= Case false) (let Case (let V2801 (shen.lazyderef V2858 V2861) (if (cons? V2801) (let V2802 (shen.lazyderef (hd V2801) V2861) (if (= define V2802) (let V2803 (shen.lazyderef (tl V2801) V2861) (if (cons? V2803) (let F (hd V2803) (let X (tl V2803) (do (shen.incinfs) (cut Throwcontrol V2861 (freeze (shen.t*-def (cons define (cons F X)) V2859 V2860 V2861 V2862)))))) false)) false)) false)) (if (= Case false) (let Case (let V2804 (shen.lazyderef V2858 V2861) (if (cons? V2804) (let V2805 (shen.lazyderef (hd V2804) V2861) (if (= defcc V2805) (let V2806 (shen.lazyderef (tl V2804) V2861) (if (cons? V2806) (let F (hd V2806) (let X (tl V2806) (do (shen.incinfs) (cut Throwcontrol V2861 (freeze (shen.t*-defcc (cons defcc (cons F X)) V2859 V2860 V2861 V2862)))))) false)) false)) false)) (if (= Case false) (let Case (let V2807 (shen.lazyderef V2858 V2861) (if (cons? V2807) (let V2808 (shen.lazyderef (hd V2807) V2861) (if (= defmacro V2808) (let V2809 (shen.lazyderef V2859 V2861) (if (= unit V2809) (do (shen.incinfs) (cut Throwcontrol V2861 V2862)) (if (shen.pvar? V2809) (do (shen.bindv V2809 unit V2861) (let Result (do (shen.incinfs) (cut Throwcontrol V2861 V2862)) (do (shen.unbindv V2809 V2861) Result))) false))) false)) false)) (if (= Case false) (let Case (let V2810 (shen.lazyderef V2858 V2861) (if (cons? V2810) (let V2811 (shen.lazyderef (hd V2810) V2861) (if (= shen.process-datatype V2811) (let V2812 (shen.lazyderef V2859 V2861) (if (= symbol V2812) (do (shen.incinfs) (thaw V2862)) (if (shen.pvar? V2812) (do (shen.bindv V2812 symbol V2861) (let Result (do (shen.incinfs) (thaw V2862)) (do (shen.unbindv V2812 V2861) Result))) false))) false)) false)) (if (= Case false) (let Case (let V2813 (shen.lazyderef V2858 V2861) (if (cons? V2813) (let V2814 (shen.lazyderef (hd V2813) V2861) (if (= shen.synonyms-help V2814) (let V2815 (shen.lazyderef V2859 V2861) (if (= symbol V2815) (do (shen.incinfs) (thaw V2862)) (if (shen.pvar? V2815) (do (shen.bindv V2815 symbol V2861) (let Result (do (shen.incinfs) (thaw V2862)) (do (shen.unbindv V2815 V2861) Result))) false))) false)) false)) (if (= Case false) (let Datatypes (shen.newpv V2861) (do (shen.incinfs) (bind Datatypes (value shen.*datatypes*) V2861 (freeze (shen.udefs* (cons V2858 (cons : (cons V2859 ()))) V2860 Datatypes V2861 V2862))))) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)))))

(defun shen.t*-hyps (V2863 V2864 V2865 V2866) (let Case (let V2608 (shen.lazyderef V2863 V2865) (if (cons? V2608) (let V2609 (shen.lazyderef (hd V2608) V2865) (if (cons? V2609) (let V2610 (shen.lazyderef (hd V2609) V2865) (if (cons? V2610) (let V2611 (shen.lazyderef (hd V2610) V2865) (if (= cons V2611) (let V2612 (shen.lazyderef (tl V2610) V2865) (if (cons? V2612) (let X (hd V2612) (let V2613 (shen.lazyderef (tl V2612) V2865) (if (cons? V2613) (let Y (hd V2613) (let V2614 (shen.lazyderef (tl V2613) V2865) (if (= () V2614) (let V2615 (shen.lazyderef (tl V2609) V2865) (if (cons? V2615) (let V2616 (shen.lazyderef (hd V2615) V2865) (if (= : V2616) (let V2617 (shen.lazyderef (tl V2615) V2865) (if (cons? V2617) (let V2618 (shen.lazyderef (hd V2617) V2865) (if (cons? V2618) (let V2619 (shen.lazyderef (hd V2618) V2865) (if (= list V2619) (let V2620 (shen.lazyderef (tl V2618) V2865) (if (cons? V2620) (let A (hd V2620) (let V2621 (shen.lazyderef (tl V2620) V2865) (if (= () V2621) (let V2622 (shen.lazyderef (tl V2617) V2865) (if (= () V2622) (let Hyp (tl V2608) (do (shen.incinfs) (bind V2864 (cons (cons (shen.lazyderef X V2865) (cons : (cons (shen.lazyderef A V2865) ()))) (cons (cons (shen.lazyderef Y V2865) (cons : (cons (cons list (cons (shen.lazyderef A V2865) ())) ()))) (shen.lazyderef Hyp V2865))) V2865 V2866))) (if (shen.pvar? V2622) (do (shen.bindv V2622 () V2865) (let Result (let Hyp (tl V2608) (do (shen.incinfs) (bind V2864 (cons (cons (shen.lazyderef X V2865) (cons : (cons (shen.lazyderef A V2865) ()))) (cons (cons (shen.lazyderef Y V2865) (cons : (cons (cons list (cons (shen.lazyderef A V2865) ())) ()))) (shen.lazyderef Hyp V2865))) V2865 V2866))) (do (shen.unbindv V2622 V2865) Result))) false))) (if (shen.pvar? V2621) (do (shen.bindv V2621 () V2865) (let Result (let V2623 (shen.lazyderef (tl V2617) V2865) (if (= () V2623) (let Hyp (tl V2608) (do (shen.incinfs) (bind V2864 (cons (cons (shen.lazyderef X V2865) (cons : (cons (shen.lazyderef A V2865) ()))) (cons (cons (shen.lazyderef Y V2865) (cons : (cons (cons list (cons (shen.lazyderef A V2865) ())) ()))) (shen.lazyderef Hyp V2865))) V2865 V2866))) (if (shen.pvar? V2623) (do (shen.bindv V2623 () V2865) (let Result (let Hyp (tl V2608) (do (shen.incinfs) (bind V2864 (cons (cons (shen.lazyderef X V2865) (cons : (cons (shen.lazyderef A V2865) ()))) (cons (cons (shen.lazyderef Y V2865) (cons : (cons (cons list (cons (shen.lazyderef A V2865) ())) ()))) (shen.lazyderef Hyp V2865))) V2865 V2866))) (do (shen.unbindv V2623 V2865) Result))) false))) (do (shen.unbindv V2621 V2865) Result))) false)))) (if (shen.pvar? V2620) (let A (shen.newpv V2865) (do (shen.bindv V2620 (cons A ()) V2865) (let Result (let V2624 (shen.lazyderef (tl V2617) V2865) (if (= () V2624) (let Hyp (tl V2608) (do (shen.incinfs) (bind V2864 (cons (cons (shen.lazyderef X V2865) (cons : (cons (shen.lazyderef A V2865) ()))) (cons (cons (shen.lazyderef Y V2865) (cons : (cons (cons list (cons (shen.lazyderef A V2865) ())) ()))) (shen.lazyderef Hyp V2865))) V2865 V2866))) (if (shen.pvar? V2624) (do (shen.bindv V2624 () V2865) (let Result (let Hyp (tl V2608) (do (shen.incinfs) (bind V2864 (cons (cons (shen.lazyderef X V2865) (cons : (cons (shen.lazyderef A V2865) ()))) (cons (cons (shen.lazyderef Y V2865) (cons : (cons (cons list (cons (shen.lazyderef A V2865) ())) ()))) (shen.lazyderef Hyp V2865))) V2865 V2866))) (do (shen.unbindv V2624 V2865) Result))) false))) (do (shen.unbindv V2620 V2865) Result)))) false))) (if (shen.pvar? V2619) (do (shen.bindv V2619 list V2865) (let Result (let V2625 (shen.lazyderef (tl V2618) V2865) (if (cons? V2625) (let A (hd V2625) (let V2626 (shen.lazyderef (tl V2625) V2865) (if (= () V2626) (let V2627 (shen.lazyderef (tl V2617) V2865) (if (= () V2627) (let Hyp (tl V2608) (do (shen.incinfs) (bind V2864 (cons (cons (shen.lazyderef X V2865) (cons : (cons (shen.lazyderef A V2865) ()))) (cons (cons (shen.lazyderef Y V2865) (cons : (cons (cons list (cons (shen.lazyderef A V2865) ())) ()))) (shen.lazyderef Hyp V2865))) V2865 V2866))) (if (shen.pvar? V2627) (do (shen.bindv V2627 () V2865) (let Result (let Hyp (tl V2608) (do (shen.incinfs) (bind V2864 (cons (cons (shen.lazyderef X V2865) (cons : (cons (shen.lazyderef A V2865) ()))) (cons (cons (shen.lazyderef Y V2865) (cons : (cons (cons list (cons (shen.lazyderef A V2865) ())) ()))) (shen.lazyderef Hyp V2865))) V2865 V2866))) (do (shen.unbindv V2627 V2865) Result))) false))) (if (shen.pvar? V2626) (do (shen.bindv V2626 () V2865) (let Result (let V2628 (shen.lazyderef (tl V2617) V2865) (if (= () V2628) (let Hyp (tl V2608) (do (shen.incinfs) (bind V2864 (cons (cons (shen.lazyderef X V2865) (cons : (cons (shen.lazyderef A V2865) ()))) (cons (cons (shen.lazyderef Y V2865) (cons : (cons (cons list (cons (shen.lazyderef A V2865) ())) ()))) (shen.lazyderef Hyp V2865))) V2865 V2866))) (if (shen.pvar? V2628) (do (shen.bindv V2628 () V2865) (let Result (let Hyp (tl V2608) (do (shen.incinfs) (bind V2864 (cons (cons (shen.lazyderef X V2865) (cons : (cons (shen.lazyderef A V2865) ()))) (cons (cons (shen.lazyderef Y V2865) (cons : (cons (cons list (cons (shen.lazyderef A V2865) ())) ()))) (shen.lazyderef Hyp V2865))) V2865 V2866))) (do (shen.unbindv V2628 V2865) Result))) false))) (do (shen.unbindv V2626 V2865) Result))) false)))) (if (shen.pvar? V2625) (let A (shen.newpv V2865) (do (shen.bindv V2625 (cons A ()) V2865) (let Result (let V2629 (shen.lazyderef (tl V2617) V2865) (if (= () V2629) (let Hyp (tl V2608) (do (shen.incinfs) (bind V2864 (cons (cons (shen.lazyderef X V2865) (cons : (cons (shen.lazyderef A V2865) ()))) (cons (cons (shen.lazyderef Y V2865) (cons : (cons (cons list (cons (shen.lazyderef A V2865) ())) ()))) (shen.lazyderef Hyp V2865))) V2865 V2866))) (if (shen.pvar? V2629) (do (shen.bindv V2629 () V2865) (let Result (let Hyp (tl V2608) (do (shen.incinfs) (bind V2864 (cons (cons (shen.lazyderef X V2865) (cons : (cons (shen.lazyderef A V2865) ()))) (cons (cons (shen.lazyderef Y V2865) (cons : (cons (cons list (cons (shen.lazyderef A V2865) ())) ()))) (shen.lazyderef Hyp V2865))) V2865 V2866))) (do (shen.unbindv V2629 V2865) Result))) false))) (do (shen.unbindv V2625 V2865) Result)))) false))) (do (shen.unbindv V2619 V2865) Result))) false))) (if (shen.pvar? V2618) (let A (shen.newpv V2865) (do (shen.bindv V2618 (cons list (cons A ())) V2865) (let Result (let V2630 (shen.lazyderef (tl V2617) V2865) (if (= () V2630) (let Hyp (tl V2608) (do (shen.incinfs) (bind V2864 (cons (cons (shen.lazyderef X V2865) (cons : (cons (shen.lazyderef A V2865) ()))) (cons (cons (shen.lazyderef Y V2865) (cons : (cons (cons list (cons (shen.lazyderef A V2865) ())) ()))) (shen.lazyderef Hyp V2865))) V2865 V2866))) (if (shen.pvar? V2630) (do (shen.bindv V2630 () V2865) (let Result (let Hyp (tl V2608) (do (shen.incinfs) (bind V2864 (cons (cons (shen.lazyderef X V2865) (cons : (cons (shen.lazyderef A V2865) ()))) (cons (cons (shen.lazyderef Y V2865) (cons : (cons (cons list (cons (shen.lazyderef A V2865) ())) ()))) (shen.lazyderef Hyp V2865))) V2865 V2866))) (do (shen.unbindv V2630 V2865) Result))) false))) (do (shen.unbindv V2618 V2865) Result)))) false))) false)) false)) false)) false))) false))) false)) false)) false)) false)) false)) (if (= Case false) (let Case (let V2631 (shen.lazyderef V2863 V2865) (if (cons? V2631) (let V2632 (shen.lazyderef (hd V2631) V2865) (if (cons? V2632) (let V2633 (shen.lazyderef (hd V2632) V2865) (if (cons? V2633) (let V2634 (shen.lazyderef (hd V2633) V2865) (if (= @p V2634) (let V2635 (shen.lazyderef (tl V2633) V2865) (if (cons? V2635) (let X (hd V2635) (let V2636 (shen.lazyderef (tl V2635) V2865) (if (cons? V2636) (let Y (hd V2636) (let V2637 (shen.lazyderef (tl V2636) V2865) (if (= () V2637) (let V2638 (shen.lazyderef (tl V2632) V2865) (if (cons? V2638) (let V2639 (shen.lazyderef (hd V2638) V2865) (if (= : V2639) (let V2640 (shen.lazyderef (tl V2638) V2865) (if (cons? V2640) (let V2641 (shen.lazyderef (hd V2640) V2865) (if (cons? V2641) (let A (hd V2641) (let V2642 (shen.lazyderef (tl V2641) V2865) (if (cons? V2642) (let V2643 (shen.lazyderef (hd V2642) V2865) (if (= * V2643) (let V2644 (shen.lazyderef (tl V2642) V2865) (if (cons? V2644) (let B (hd V2644) (let V2645 (shen.lazyderef (tl V2644) V2865) (if (= () V2645) (let V2646 (shen.lazyderef (tl V2640) V2865) (if (= () V2646) (let Hyp (tl V2631) (do (shen.incinfs) (bind V2864 (cons (cons (shen.lazyderef X V2865) (cons : (cons (shen.lazyderef A V2865) ()))) (cons (cons (shen.lazyderef Y V2865) (cons : (cons (shen.lazyderef B V2865) ()))) (shen.lazyderef Hyp V2865))) V2865 V2866))) (if (shen.pvar? V2646) (do (shen.bindv V2646 () V2865) (let Result (let Hyp (tl V2631) (do (shen.incinfs) (bind V2864 (cons (cons (shen.lazyderef X V2865) (cons : (cons (shen.lazyderef A V2865) ()))) (cons (cons (shen.lazyderef Y V2865) (cons : (cons (shen.lazyderef B V2865) ()))) (shen.lazyderef Hyp V2865))) V2865 V2866))) (do (shen.unbindv V2646 V2865) Result))) false))) (if (shen.pvar? V2645) (do (shen.bindv V2645 () V2865) (let Result (let V2647 (shen.lazyderef (tl V2640) V2865) (if (= () V2647) (let Hyp (tl V2631) (do (shen.incinfs) (bind V2864 (cons (cons (shen.lazyderef X V2865) (cons : (cons (shen.lazyderef A V2865) ()))) (cons (cons (shen.lazyderef Y V2865) (cons : (cons (shen.lazyderef B V2865) ()))) (shen.lazyderef Hyp V2865))) V2865 V2866))) (if (shen.pvar? V2647) (do (shen.bindv V2647 () V2865) (let Result (let Hyp (tl V2631) (do (shen.incinfs) (bind V2864 (cons (cons (shen.lazyderef X V2865) (cons : (cons (shen.lazyderef A V2865) ()))) (cons (cons (shen.lazyderef Y V2865) (cons : (cons (shen.lazyderef B V2865) ()))) (shen.lazyderef Hyp V2865))) V2865 V2866))) (do (shen.unbindv V2647 V2865) Result))) false))) (do (shen.unbindv V2645 V2865) Result))) false)))) (if (shen.pvar? V2644) (let B (shen.newpv V2865) (do (shen.bindv V2644 (cons B ()) V2865) (let Result (let V2648 (shen.lazyderef (tl V2640) V2865) (if (= () V2648) (let Hyp (tl V2631) (do (shen.incinfs) (bind V2864 (cons (cons (shen.lazyderef X V2865) (cons : (cons (shen.lazyderef A V2865) ()))) (cons (cons (shen.lazyderef Y V2865) (cons : (cons (shen.lazyderef B V2865) ()))) (shen.lazyderef Hyp V2865))) V2865 V2866))) (if (shen.pvar? V2648) (do (shen.bindv V2648 () V2865) (let Result (let Hyp (tl V2631) (do (shen.incinfs) (bind V2864 (cons (cons (shen.lazyderef X V2865) (cons : (cons (shen.lazyderef A V2865) ()))) (cons (cons (shen.lazyderef Y V2865) (cons : (cons (shen.lazyderef B V2865) ()))) (shen.lazyderef Hyp V2865))) V2865 V2866))) (do (shen.unbindv V2648 V2865) Result))) false))) (do (shen.unbindv V2644 V2865) Result)))) false))) (if (shen.pvar? V2643) (do (shen.bindv V2643 * V2865) (let Result (let V2649 (shen.lazyderef (tl V2642) V2865) (if (cons? V2649) (let B (hd V2649) (let V2650 (shen.lazyderef (tl V2649) V2865) (if (= () V2650) (let V2651 (shen.lazyderef (tl V2640) V2865) (if (= () V2651) (let Hyp (tl V2631) (do (shen.incinfs) (bind V2864 (cons (cons (shen.lazyderef X V2865) (cons : (cons (shen.lazyderef A V2865) ()))) (cons (cons (shen.lazyderef Y V2865) (cons : (cons (shen.lazyderef B V2865) ()))) (shen.lazyderef Hyp V2865))) V2865 V2866))) (if (shen.pvar? V2651) (do (shen.bindv V2651 () V2865) (let Result (let Hyp (tl V2631) (do (shen.incinfs) (bind V2864 (cons (cons (shen.lazyderef X V2865) (cons : (cons (shen.lazyderef A V2865) ()))) (cons (cons (shen.lazyderef Y V2865) (cons : (cons (shen.lazyderef B V2865) ()))) (shen.lazyderef Hyp V2865))) V2865 V2866))) (do (shen.unbindv V2651 V2865) Result))) false))) (if (shen.pvar? V2650) (do (shen.bindv V2650 () V2865) (let Result (let V2652 (shen.lazyderef (tl V2640) V2865) (if (= () V2652) (let Hyp (tl V2631) (do (shen.incinfs) (bind V2864 (cons (cons (shen.lazyderef X V2865) (cons : (cons (shen.lazyderef A V2865) ()))) (cons (cons (shen.lazyderef Y V2865) (cons : (cons (shen.lazyderef B V2865) ()))) (shen.lazyderef Hyp V2865))) V2865 V2866))) (if (shen.pvar? V2652) (do (shen.bindv V2652 () V2865) (let Result (let Hyp (tl V2631) (do (shen.incinfs) (bind V2864 (cons (cons (shen.lazyderef X V2865) (cons : (cons (shen.lazyderef A V2865) ()))) (cons (cons (shen.lazyderef Y V2865) (cons : (cons (shen.lazyderef B V2865) ()))) (shen.lazyderef Hyp V2865))) V2865 V2866))) (do (shen.unbindv V2652 V2865) Result))) false))) (do (shen.unbindv V2650 V2865) Result))) false)))) (if (shen.pvar? V2649) (let B (shen.newpv V2865) (do (shen.bindv V2649 (cons B ()) V2865) (let Result (let V2653 (shen.lazyderef (tl V2640) V2865) (if (= () V2653) (let Hyp (tl V2631) (do (shen.incinfs) (bind V2864 (cons (cons (shen.lazyderef X V2865) (cons : (cons (shen.lazyderef A V2865) ()))) (cons (cons (shen.lazyderef Y V2865) (cons : (cons (shen.lazyderef B V2865) ()))) (shen.lazyderef Hyp V2865))) V2865 V2866))) (if (shen.pvar? V2653) (do (shen.bindv V2653 () V2865) (let Result (let Hyp (tl V2631) (do (shen.incinfs) (bind V2864 (cons (cons (shen.lazyderef X V2865) (cons : (cons (shen.lazyderef A V2865) ()))) (cons (cons (shen.lazyderef Y V2865) (cons : (cons (shen.lazyderef B V2865) ()))) (shen.lazyderef Hyp V2865))) V2865 V2866))) (do (shen.unbindv V2653 V2865) Result))) false))) (do (shen.unbindv V2649 V2865) Result)))) false))) (do (shen.unbindv V2643 V2865) Result))) false))) (if (shen.pvar? V2642) (let B (shen.newpv V2865) (do (shen.bindv V2642 (cons * (cons B ())) V2865) (let Result (let V2654 (shen.lazyderef (tl V2640) V2865) (if (= () V2654) (let Hyp (tl V2631) (do (shen.incinfs) (bind V2864 (cons (cons (shen.lazyderef X V2865) (cons : (cons (shen.lazyderef A V2865) ()))) (cons (cons (shen.lazyderef Y V2865) (cons : (cons (shen.lazyderef B V2865) ()))) (shen.lazyderef Hyp V2865))) V2865 V2866))) (if (shen.pvar? V2654) (do (shen.bindv V2654 () V2865) (let Result (let Hyp (tl V2631) (do (shen.incinfs) (bind V2864 (cons (cons (shen.lazyderef X V2865) (cons : (cons (shen.lazyderef A V2865) ()))) (cons (cons (shen.lazyderef Y V2865) (cons : (cons (shen.lazyderef B V2865) ()))) (shen.lazyderef Hyp V2865))) V2865 V2866))) (do (shen.unbindv V2654 V2865) Result))) false))) (do (shen.unbindv V2642 V2865) Result)))) false)))) (if (shen.pvar? V2641) (let A (shen.newpv V2865) (let B (shen.newpv V2865) (do (shen.bindv V2641 (cons A (cons * (cons B ()))) V2865) (let Result (let V2655 (shen.lazyderef (tl V2640) V2865) (if (= () V2655) (let Hyp (tl V2631) (do (shen.incinfs) (bind V2864 (cons (cons (shen.lazyderef X V2865) (cons : (cons (shen.lazyderef A V2865) ()))) (cons (cons (shen.lazyderef Y V2865) (cons : (cons (shen.lazyderef B V2865) ()))) (shen.lazyderef Hyp V2865))) V2865 V2866))) (if (shen.pvar? V2655) (do (shen.bindv V2655 () V2865) (let Result (let Hyp (tl V2631) (do (shen.incinfs) (bind V2864 (cons (cons (shen.lazyderef X V2865) (cons : (cons (shen.lazyderef A V2865) ()))) (cons (cons (shen.lazyderef Y V2865) (cons : (cons (shen.lazyderef B V2865) ()))) (shen.lazyderef Hyp V2865))) V2865 V2866))) (do (shen.unbindv V2655 V2865) Result))) false))) (do (shen.unbindv V2641 V2865) Result))))) false))) false)) false)) false)) false))) false))) false)) false)) false)) false)) false)) (if (= Case false) (let Case (let V2656 (shen.lazyderef V2863 V2865) (if (cons? V2656) (let V2657 (shen.lazyderef (hd V2656) V2865) (if (cons? V2657) (let V2658 (shen.lazyderef (hd V2657) V2865) (if (cons? V2658) (let V2659 (shen.lazyderef (hd V2658) V2865) (if (= @v V2659) (let V2660 (shen.lazyderef (tl V2658) V2865) (if (cons? V2660) (let X (hd V2660) (let V2661 (shen.lazyderef (tl V2660) V2865) (if (cons? V2661) (let Y (hd V2661) (let V2662 (shen.lazyderef (tl V2661) V2865) (if (= () V2662) (let V2663 (shen.lazyderef (tl V2657) V2865) (if (cons? V2663) (let V2664 (shen.lazyderef (hd V2663) V2865) (if (= : V2664) (let V2665 (shen.lazyderef (tl V2663) V2865) (if (cons? V2665) (let V2666 (shen.lazyderef (hd V2665) V2865) (if (cons? V2666) (let V2667 (shen.lazyderef (hd V2666) V2865) (if (= vector V2667) (let V2668 (shen.lazyderef (tl V2666) V2865) (if (cons? V2668) (let A (hd V2668) (let V2669 (shen.lazyderef (tl V2668) V2865) (if (= () V2669) (let V2670 (shen.lazyderef (tl V2665) V2865) (if (= () V2670) (let Hyp (tl V2656) (do (shen.incinfs) (bind V2864 (cons (cons (shen.lazyderef X V2865) (cons : (cons (shen.lazyderef A V2865) ()))) (cons (cons (shen.lazyderef Y V2865) (cons : (cons (cons vector (cons (shen.lazyderef A V2865) ())) ()))) (shen.lazyderef Hyp V2865))) V2865 V2866))) (if (shen.pvar? V2670) (do (shen.bindv V2670 () V2865) (let Result (let Hyp (tl V2656) (do (shen.incinfs) (bind V2864 (cons (cons (shen.lazyderef X V2865) (cons : (cons (shen.lazyderef A V2865) ()))) (cons (cons (shen.lazyderef Y V2865) (cons : (cons (cons vector (cons (shen.lazyderef A V2865) ())) ()))) (shen.lazyderef Hyp V2865))) V2865 V2866))) (do (shen.unbindv V2670 V2865) Result))) false))) (if (shen.pvar? V2669) (do (shen.bindv V2669 () V2865) (let Result (let V2671 (shen.lazyderef (tl V2665) V2865) (if (= () V2671) (let Hyp (tl V2656) (do (shen.incinfs) (bind V2864 (cons (cons (shen.lazyderef X V2865) (cons : (cons (shen.lazyderef A V2865) ()))) (cons (cons (shen.lazyderef Y V2865) (cons : (cons (cons vector (cons (shen.lazyderef A V2865) ())) ()))) (shen.lazyderef Hyp V2865))) V2865 V2866))) (if (shen.pvar? V2671) (do (shen.bindv V2671 () V2865) (let Result (let Hyp (tl V2656) (do (shen.incinfs) (bind V2864 (cons (cons (shen.lazyderef X V2865) (cons : (cons (shen.lazyderef A V2865) ()))) (cons (cons (shen.lazyderef Y V2865) (cons : (cons (cons vector (cons (shen.lazyderef A V2865) ())) ()))) (shen.lazyderef Hyp V2865))) V2865 V2866))) (do (shen.unbindv V2671 V2865) Result))) false))) (do (shen.unbindv V2669 V2865) Result))) false)))) (if (shen.pvar? V2668) (let A (shen.newpv V2865) (do (shen.bindv V2668 (cons A ()) V2865) (let Result (let V2672 (shen.lazyderef (tl V2665) V2865) (if (= () V2672) (let Hyp (tl V2656) (do (shen.incinfs) (bind V2864 (cons (cons (shen.lazyderef X V2865) (cons : (cons (shen.lazyderef A V2865) ()))) (cons (cons (shen.lazyderef Y V2865) (cons : (cons (cons vector (cons (shen.lazyderef A V2865) ())) ()))) (shen.lazyderef Hyp V2865))) V2865 V2866))) (if (shen.pvar? V2672) (do (shen.bindv V2672 () V2865) (let Result (let Hyp (tl V2656) (do (shen.incinfs) (bind V2864 (cons (cons (shen.lazyderef X V2865) (cons : (cons (shen.lazyderef A V2865) ()))) (cons (cons (shen.lazyderef Y V2865) (cons : (cons (cons vector (cons (shen.lazyderef A V2865) ())) ()))) (shen.lazyderef Hyp V2865))) V2865 V2866))) (do (shen.unbindv V2672 V2865) Result))) false))) (do (shen.unbindv V2668 V2865) Result)))) false))) (if (shen.pvar? V2667) (do (shen.bindv V2667 vector V2865) (let Result (let V2673 (shen.lazyderef (tl V2666) V2865) (if (cons? V2673) (let A (hd V2673) (let V2674 (shen.lazyderef (tl V2673) V2865) (if (= () V2674) (let V2675 (shen.lazyderef (tl V2665) V2865) (if (= () V2675) (let Hyp (tl V2656) (do (shen.incinfs) (bind V2864 (cons (cons (shen.lazyderef X V2865) (cons : (cons (shen.lazyderef A V2865) ()))) (cons (cons (shen.lazyderef Y V2865) (cons : (cons (cons vector (cons (shen.lazyderef A V2865) ())) ()))) (shen.lazyderef Hyp V2865))) V2865 V2866))) (if (shen.pvar? V2675) (do (shen.bindv V2675 () V2865) (let Result (let Hyp (tl V2656) (do (shen.incinfs) (bind V2864 (cons (cons (shen.lazyderef X V2865) (cons : (cons (shen.lazyderef A V2865) ()))) (cons (cons (shen.lazyderef Y V2865) (cons : (cons (cons vector (cons (shen.lazyderef A V2865) ())) ()))) (shen.lazyderef Hyp V2865))) V2865 V2866))) (do (shen.unbindv V2675 V2865) Result))) false))) (if (shen.pvar? V2674) (do (shen.bindv V2674 () V2865) (let Result (let V2676 (shen.lazyderef (tl V2665) V2865) (if (= () V2676) (let Hyp (tl V2656) (do (shen.incinfs) (bind V2864 (cons (cons (shen.lazyderef X V2865) (cons : (cons (shen.lazyderef A V2865) ()))) (cons (cons (shen.lazyderef Y V2865) (cons : (cons (cons vector (cons (shen.lazyderef A V2865) ())) ()))) (shen.lazyderef Hyp V2865))) V2865 V2866))) (if (shen.pvar? V2676) (do (shen.bindv V2676 () V2865) (let Result (let Hyp (tl V2656) (do (shen.incinfs) (bind V2864 (cons (cons (shen.lazyderef X V2865) (cons : (cons (shen.lazyderef A V2865) ()))) (cons (cons (shen.lazyderef Y V2865) (cons : (cons (cons vector (cons (shen.lazyderef A V2865) ())) ()))) (shen.lazyderef Hyp V2865))) V2865 V2866))) (do (shen.unbindv V2676 V2865) Result))) false))) (do (shen.unbindv V2674 V2865) Result))) false)))) (if (shen.pvar? V2673) (let A (shen.newpv V2865) (do (shen.bindv V2673 (cons A ()) V2865) (let Result (let V2677 (shen.lazyderef (tl V2665) V2865) (if (= () V2677) (let Hyp (tl V2656) (do (shen.incinfs) (bind V2864 (cons (cons (shen.lazyderef X V2865) (cons : (cons (shen.lazyderef A V2865) ()))) (cons (cons (shen.lazyderef Y V2865) (cons : (cons (cons vector (cons (shen.lazyderef A V2865) ())) ()))) (shen.lazyderef Hyp V2865))) V2865 V2866))) (if (shen.pvar? V2677) (do (shen.bindv V2677 () V2865) (let Result (let Hyp (tl V2656) (do (shen.incinfs) (bind V2864 (cons (cons (shen.lazyderef X V2865) (cons : (cons (shen.lazyderef A V2865) ()))) (cons (cons (shen.lazyderef Y V2865) (cons : (cons (cons vector (cons (shen.lazyderef A V2865) ())) ()))) (shen.lazyderef Hyp V2865))) V2865 V2866))) (do (shen.unbindv V2677 V2865) Result))) false))) (do (shen.unbindv V2673 V2865) Result)))) false))) (do (shen.unbindv V2667 V2865) Result))) false))) (if (shen.pvar? V2666) (let A (shen.newpv V2865) (do (shen.bindv V2666 (cons vector (cons A ())) V2865) (let Result (let V2678 (shen.lazyderef (tl V2665) V2865) (if (= () V2678) (let Hyp (tl V2656) (do (shen.incinfs) (bind V2864 (cons (cons (shen.lazyderef X V2865) (cons : (cons (shen.lazyderef A V2865) ()))) (cons (cons (shen.lazyderef Y V2865) (cons : (cons (cons vector (cons (shen.lazyderef A V2865) ())) ()))) (shen.lazyderef Hyp V2865))) V2865 V2866))) (if (shen.pvar? V2678) (do (shen.bindv V2678 () V2865) (let Result (let Hyp (tl V2656) (do (shen.incinfs) (bind V2864 (cons (cons (shen.lazyderef X V2865) (cons : (cons (shen.lazyderef A V2865) ()))) (cons (cons (shen.lazyderef Y V2865) (cons : (cons (cons vector (cons (shen.lazyderef A V2865) ())) ()))) (shen.lazyderef Hyp V2865))) V2865 V2866))) (do (shen.unbindv V2678 V2865) Result))) false))) (do (shen.unbindv V2666 V2865) Result)))) false))) false)) false)) false)) false))) false))) false)) false)) false)) false)) false)) (if (= Case false) (let Case (let V2679 (shen.lazyderef V2863 V2865) (if (cons? V2679) (let V2680 (shen.lazyderef (hd V2679) V2865) (if (cons? V2680) (let V2681 (shen.lazyderef (hd V2680) V2865) (if (cons? V2681) (let V2682 (shen.lazyderef (hd V2681) V2865) (if (= @s V2682) (let V2683 (shen.lazyderef (tl V2681) V2865) (if (cons? V2683) (let X (hd V2683) (let V2684 (shen.lazyderef (tl V2683) V2865) (if (cons? V2684) (let Y (hd V2684) (let V2685 (shen.lazyderef (tl V2684) V2865) (if (= () V2685) (let V2686 (shen.lazyderef (tl V2680) V2865) (if (cons? V2686) (let V2687 (shen.lazyderef (hd V2686) V2865) (if (= : V2687) (let V2688 (shen.lazyderef (tl V2686) V2865) (if (cons? V2688) (let V2689 (shen.lazyderef (hd V2688) V2865) (if (= string V2689) (let V2690 (shen.lazyderef (tl V2688) V2865) (if (= () V2690) (let Hyp (tl V2679) (do (shen.incinfs) (bind V2864 (cons (cons (shen.lazyderef X V2865) (cons : (cons string ()))) (cons (cons (shen.lazyderef Y V2865) (cons : (cons string ()))) (shen.lazyderef Hyp V2865))) V2865 V2866))) (if (shen.pvar? V2690) (do (shen.bindv V2690 () V2865) (let Result (let Hyp (tl V2679) (do (shen.incinfs) (bind V2864 (cons (cons (shen.lazyderef X V2865) (cons : (cons string ()))) (cons (cons (shen.lazyderef Y V2865) (cons : (cons string ()))) (shen.lazyderef Hyp V2865))) V2865 V2866))) (do (shen.unbindv V2690 V2865) Result))) false))) (if (shen.pvar? V2689) (do (shen.bindv V2689 string V2865) (let Result (let V2691 (shen.lazyderef (tl V2688) V2865) (if (= () V2691) (let Hyp (tl V2679) (do (shen.incinfs) (bind V2864 (cons (cons (shen.lazyderef X V2865) (cons : (cons string ()))) (cons (cons (shen.lazyderef Y V2865) (cons : (cons string ()))) (shen.lazyderef Hyp V2865))) V2865 V2866))) (if (shen.pvar? V2691) (do (shen.bindv V2691 () V2865) (let Result (let Hyp (tl V2679) (do (shen.incinfs) (bind V2864 (cons (cons (shen.lazyderef X V2865) (cons : (cons string ()))) (cons (cons (shen.lazyderef Y V2865) (cons : (cons string ()))) (shen.lazyderef Hyp V2865))) V2865 V2866))) (do (shen.unbindv V2691 V2865) Result))) false))) (do (shen.unbindv V2689 V2865) Result))) false))) false)) false)) false)) false))) false))) false)) false)) false)) false)) false)) (if (= Case false) (let V2692 (shen.lazyderef V2863 V2865) (if (cons? V2692) (let X (hd V2692) (let Hyp (tl V2692) (let NewHyps (shen.newpv V2865) (do (shen.incinfs) (bind V2864 (cons (shen.lazyderef X V2865) (shen.lazyderef NewHyps V2865)) V2865 (freeze (shen.t*-hyps Hyp NewHyps V2865 V2866))))))) false)) Case)) Case)) Case)) Case)))

(defun shen.show (V2879 V2880 V2881 V2882) (cond ((value shen.*spy*) (do (shen.line) (do (shen.show-p (shen.deref V2879 V2881)) (do (nl 1) (do (nl 1) (do (shen.show-assumptions (shen.deref V2880 V2881) 1) (do (shen.prhush "
> " (stoutput)) (do (shen.pause-for-user) (thaw V2882))))))))) (true (thaw V2882))))

(defun shen.line () (let Infs (inferences) (shen.prhush (cn "____________________________________________________________ " (shen.app Infs (cn " inference" (shen.app (if (= 1 Infs) "" "s") " 
?- " shen.a)) shen.a)) (stoutput))))

(defun shen.show-p (V2883) (cond ((and (cons? V2883) (and (cons? (tl V2883)) (and (= : (hd (tl V2883))) (and (cons? (tl (tl V2883))) (= () (tl (tl (tl V2883)))))))) (shen.prhush (shen.app (hd V2883) (cn " : " (shen.app (hd (tl (tl V2883))) "" shen.r)) shen.r) (stoutput))) (true (shen.prhush (shen.app V2883 "" shen.r) (stoutput)))))

(defun shen.show-assumptions (V2886 V2887) (cond ((= () V2886) shen.skip) ((cons? V2886) (do (shen.prhush (shen.app V2887 ". " shen.a) (stoutput)) (do (shen.show-p (hd V2886)) (do (nl 1) (shen.show-assumptions (tl V2886) (+ V2887 1)))))) (true (shen.sys-error shen.show-assumptions))))

(defun shen.pause-for-user () (let Byte (read-byte (stinput)) (if (= Byte 94) (simple-error "input aborted
") (nl 1))))

(defun shen.typedf? (V2888) (cons? (assoc V2888 (value shen.*signedfuncs*))))

(defun shen.sigf (V2889) (concat shen.type-signature-of- V2889))

(defun shen.placeholder () (gensym &&))

(defun shen.base (V2890 V2891 V2892 V2893) (let Case (let V2595 (shen.lazyderef V2891 V2892) (if (= number V2595) (do (shen.incinfs) (fwhen (number? (shen.lazyderef V2890 V2892)) V2892 V2893)) (if (shen.pvar? V2595) (do (shen.bindv V2595 number V2892) (let Result (do (shen.incinfs) (fwhen (number? (shen.lazyderef V2890 V2892)) V2892 V2893)) (do (shen.unbindv V2595 V2892) Result))) false))) (if (= Case false) (let Case (let V2596 (shen.lazyderef V2891 V2892) (if (= boolean V2596) (do (shen.incinfs) (fwhen (boolean? (shen.lazyderef V2890 V2892)) V2892 V2893)) (if (shen.pvar? V2596) (do (shen.bindv V2596 boolean V2892) (let Result (do (shen.incinfs) (fwhen (boolean? (shen.lazyderef V2890 V2892)) V2892 V2893)) (do (shen.unbindv V2596 V2892) Result))) false))) (if (= Case false) (let Case (let V2597 (shen.lazyderef V2891 V2892) (if (= string V2597) (do (shen.incinfs) (fwhen (string? (shen.lazyderef V2890 V2892)) V2892 V2893)) (if (shen.pvar? V2597) (do (shen.bindv V2597 string V2892) (let Result (do (shen.incinfs) (fwhen (string? (shen.lazyderef V2890 V2892)) V2892 V2893)) (do (shen.unbindv V2597 V2892) Result))) false))) (if (= Case false) (let Case (let V2598 (shen.lazyderef V2891 V2892) (if (= symbol V2598) (do (shen.incinfs) (fwhen (symbol? (shen.lazyderef V2890 V2892)) V2892 (freeze (fwhen (not (shen.ue? (shen.lazyderef V2890 V2892))) V2892 V2893)))) (if (shen.pvar? V2598) (do (shen.bindv V2598 symbol V2892) (let Result (do (shen.incinfs) (fwhen (symbol? (shen.lazyderef V2890 V2892)) V2892 (freeze (fwhen (not (shen.ue? (shen.lazyderef V2890 V2892))) V2892 V2893)))) (do (shen.unbindv V2598 V2892) Result))) false))) (if (= Case false) (let V2599 (shen.lazyderef V2890 V2892) (if (= () V2599) (let V2600 (shen.lazyderef V2891 V2892) (if (cons? V2600) (let V2601 (shen.lazyderef (hd V2600) V2892) (if (= list V2601) (let V2602 (shen.lazyderef (tl V2600) V2892) (if (cons? V2602) (let A (hd V2602) (let V2603 (shen.lazyderef (tl V2602) V2892) (if (= () V2603) (do (shen.incinfs) (thaw V2893)) (if (shen.pvar? V2603) (do (shen.bindv V2603 () V2892) (let Result (do (shen.incinfs) (thaw V2893)) (do (shen.unbindv V2603 V2892) Result))) false)))) (if (shen.pvar? V2602) (let A (shen.newpv V2892) (do (shen.bindv V2602 (cons A ()) V2892) (let Result (do (shen.incinfs) (thaw V2893)) (do (shen.unbindv V2602 V2892) Result)))) false))) (if (shen.pvar? V2601) (do (shen.bindv V2601 list V2892) (let Result (let V2604 (shen.lazyderef (tl V2600) V2892) (if (cons? V2604) (let A (hd V2604) (let V2605 (shen.lazyderef (tl V2604) V2892) (if (= () V2605) (do (shen.incinfs) (thaw V2893)) (if (shen.pvar? V2605) (do (shen.bindv V2605 () V2892) (let Result (do (shen.incinfs) (thaw V2893)) (do (shen.unbindv V2605 V2892) Result))) false)))) (if (shen.pvar? V2604) (let A (shen.newpv V2892) (do (shen.bindv V2604 (cons A ()) V2892) (let Result (do (shen.incinfs) (thaw V2893)) (do (shen.unbindv V2604 V2892) Result)))) false))) (do (shen.unbindv V2601 V2892) Result))) false))) (if (shen.pvar? V2600) (let A (shen.newpv V2892) (do (shen.bindv V2600 (cons list (cons A ())) V2892) (let Result (do (shen.incinfs) (thaw V2893)) (do (shen.unbindv V2600 V2892) Result)))) false))) false)) Case)) Case)) Case)) Case)))

(defun shen.by_hypothesis (V2894 V2895 V2896 V2897 V2898) (let Case (let V2586 (shen.lazyderef V2896 V2897) (if (cons? V2586) (let V2587 (shen.lazyderef (hd V2586) V2897) (if (cons? V2587) (let Y (hd V2587) (let V2588 (shen.lazyderef (tl V2587) V2897) (if (cons? V2588) (let V2589 (shen.lazyderef (hd V2588) V2897) (if (= : V2589) (let V2590 (shen.lazyderef (tl V2588) V2897) (if (cons? V2590) (let B (hd V2590) (let V2591 (shen.lazyderef (tl V2590) V2897) (if (= () V2591) (do (shen.incinfs) (identical V2894 Y V2897 (freeze (unify! V2895 B V2897 V2898)))) false))) false)) false)) false))) false)) false)) (if (= Case false) (let V2592 (shen.lazyderef V2896 V2897) (if (cons? V2592) (let Hyp (tl V2592) (do (shen.incinfs) (shen.by_hypothesis V2894 V2895 Hyp V2897 V2898))) false)) Case)))

(defun shen.t*-def (V2899 V2900 V2901 V2902 V2903) (let V2580 (shen.lazyderef V2899 V2902) (if (cons? V2580) (let V2581 (shen.lazyderef (hd V2580) V2902) (if (= define V2581) (let V2582 (shen.lazyderef (tl V2580) V2902) (if (cons? V2582) (let F (hd V2582) (let X (tl V2582) (let E (shen.newpv V2902) (do (shen.incinfs) (shen.t*-defh (compile shen.<sig+rules> X (lambda E (if (cons? E) (simple-error (cn "parse error here: " (shen.app E "
" shen.s))) (simple-error "parse error
")))) F V2900 V2901 V2902 V2903))))) false)) false)) false)))

(defun shen.t*-defh (V2904 V2905 V2906 V2907 V2908 V2909) (let V2576 (shen.lazyderef V2904 V2908) (if (cons? V2576) (let Sig (hd V2576) (let Rules (tl V2576) (do (shen.incinfs) (shen.t*-defhh Sig (shen.ue Sig) V2905 V2906 V2907 Rules V2908 V2909)))) false)))

(defun shen.t*-defhh (V2910 V2911 V2912 V2913 V2914 V2915 V2916 V2917) (do (shen.incinfs) (shen.t*-rules V2915 V2911 1 V2912 (cons (cons V2912 (cons : (cons V2911 ()))) V2914) V2916 (freeze (shen.memo V2912 V2910 V2913 V2916 V2917)))))

(defun shen.memo (V2918 V2919 V2920 V2921 V2922) (let Jnk (shen.newpv V2921) (do (shen.incinfs) (unify! V2920 V2919 V2921 (freeze (bind Jnk (declare (shen.lazyderef V2918 V2921) (shen.lazyderef V2920 V2921)) V2921 V2922))))))

(defun shen.<sig+rules> (V2927) (let Result (let Parse_shen.<signature> (shen.<signature> V2927) (if (not (= (fail) Parse_shen.<signature>)) (let Parse_shen.<rules> (shen.<rules> Parse_shen.<signature>) (if (not (= (fail) Parse_shen.<rules>)) (shen.pair (hd Parse_shen.<rules>) (cons (shen.hdtl Parse_shen.<signature>) (shen.hdtl Parse_shen.<rules>))) (fail))) (fail))) (if (= Result (fail)) (fail) Result)))

(defun shen.ue (V2928) (cond ((and (cons? V2928) (and (cons? (tl V2928)) (and (= () (tl (tl V2928))) (= (hd V2928) protect)))) V2928) ((cons? V2928) (map shen.ue V2928)) ((variable? V2928) (concat && V2928)) (true V2928)))

(defun shen.ues (V2933) (cond ((shen.ue? V2933) (cons V2933 ())) ((cons? V2933) (union (shen.ues (hd V2933)) (shen.ues (tl V2933)))) (true ())))

(defun shen.ue? (V2934) (and (symbol? V2934) (shen.ue-h? (str V2934))))

(defun shen.ue-h? (V2941) (cond ((and (shen.+string? V2941) (and (= "&" (pos V2941 0)) (and (shen.+string? (tlstr V2941)) (= "&" (pos (tlstr V2941) 0))))) true) (true false)))

(defun shen.t*-rules (V2942 V2943 V2944 V2945 V2946 V2947 V2948) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (let V2551 (shen.lazyderef V2942 V2947) (if (= () V2551) (do (shen.incinfs) (thaw V2948)) false)) (if (= Case false) (let Case (let V2552 (shen.lazyderef V2942 V2947) (if (cons? V2552) (let V2553 (shen.lazyderef (hd V2552) V2947) (if (cons? V2553) (let V2554 (shen.lazyderef (hd V2553) V2947) (if (= () V2554) (let V2555 (shen.lazyderef (tl V2553) V2947) (if (cons? V2555) (let Action (hd V2555) (let V2556 (shen.lazyderef (tl V2555) V2947) (if (= () V2556) (let Rules (tl V2552) (let V2557 (shen.lazyderef V2943 V2947) (if (cons? V2557) (let V2558 (shen.lazyderef (hd V2557) V2947) (if (= --> V2558) (let V2559 (shen.lazyderef (tl V2557) V2947) (if (cons? V2559) (let A (hd V2559) (let V2560 (shen.lazyderef (tl V2559) V2947) (if (= () V2560) (do (shen.incinfs) (shen.t*-rule (cons () (cons (shen.ue Action) ())) A V2946 V2947 (freeze (cut Throwcontrol V2947 (freeze (shen.t*-rules Rules A (+ V2944 1) V2945 V2946 V2947 V2948)))))) false))) false)) false)) false))) false))) false)) false)) false)) false)) (if (= Case false) (let Case (let V2561 (shen.lazyderef V2942 V2947) (if (cons? V2561) (let Rule (hd V2561) (let Rules (tl V2561) (do (shen.incinfs) (shen.t*-rule (shen.ue Rule) V2943 V2946 V2947 (freeze (cut Throwcontrol V2947 (freeze (shen.t*-rules Rules V2943 (+ V2944 1) V2945 V2946 V2947 V2948)))))))) false)) (if (= Case false) (let Err (shen.newpv V2947) (do (shen.incinfs) (bind Err (simple-error (cn "type error in rule " (shen.app (shen.lazyderef V2944 V2947) (cn " of " (shen.app (shen.lazyderef V2945 V2947) "" shen.a)) shen.a))) V2947 V2948))) Case)) Case)) Case)))))

(defun shen.t*-rule (V2949 V2950 V2951 V2952 V2953) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (let V2533 (shen.lazyderef V2949 V2952) (if (cons? V2533) (let V2534 (shen.lazyderef (hd V2533) V2952) (if (= () V2534) (let V2535 (shen.lazyderef (tl V2533) V2952) (if (cons? V2535) (let Action (hd V2535) (let V2536 (shen.lazyderef (tl V2535) V2952) (if (= () V2536) (do (shen.incinfs) (cut Throwcontrol V2952 (freeze (shen.t*-action (shen.curry Action) V2950 V2951 V2952 V2953)))) false))) false)) false)) false)) (if (= Case false) (let V2537 (shen.lazyderef V2949 V2952) (if (cons? V2537) (let V2538 (shen.lazyderef (hd V2537) V2952) (if (cons? V2538) (let Pattern (hd V2538) (let Patterns (tl V2538) (let V2539 (shen.lazyderef (tl V2537) V2952) (if (cons? V2539) (let Action (hd V2539) (let V2540 (shen.lazyderef (tl V2539) V2952) (if (= () V2540) (let V2541 (shen.lazyderef V2950 V2952) (if (cons? V2541) (let A (hd V2541) (let V2542 (shen.lazyderef (tl V2541) V2952) (if (cons? V2542) (let V2543 (shen.lazyderef (hd V2542) V2952) (if (= --> V2543) (let V2544 (shen.lazyderef (tl V2542) V2952) (if (cons? V2544) (let B (hd V2544) (let V2545 (shen.lazyderef (tl V2544) V2952) (if (= () V2545) (do (shen.incinfs) (shen.t*-pattern Pattern A V2952 (freeze (cut Throwcontrol V2952 (freeze (shen.t*-rule (cons Patterns (cons Action ())) B (cons (cons Pattern (cons : (cons A ()))) V2951) V2952 V2953)))))) false))) false)) false)) false))) false)) false))) false)))) false)) false)) Case)))))

(defun shen.t*-action (V2954 V2955 V2956 V2957 V2958) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (let V2510 (shen.lazyderef V2954 V2957) (if (cons? V2510) (let V2511 (shen.lazyderef (hd V2510) V2957) (if (= where V2511) (let V2512 (shen.lazyderef (tl V2510) V2957) (if (cons? V2512) (let P (hd V2512) (let V2513 (shen.lazyderef (tl V2512) V2957) (if (cons? V2513) (let Action (hd V2513) (let V2514 (shen.lazyderef (tl V2513) V2957) (if (= () V2514) (do (shen.incinfs) (cut Throwcontrol V2957 (freeze (shen.t* (cons P (cons : (cons boolean ()))) V2956 V2957 (freeze (cut Throwcontrol V2957 (freeze (shen.t*-action Action V2955 (cons (cons P (cons : (cons verified ()))) V2956) V2957 V2958)))))))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V2515 (shen.lazyderef V2954 V2957) (if (cons? V2515) (let V2516 (shen.lazyderef (hd V2515) V2957) (if (= shen.choicepoint! V2516) (let V2517 (shen.lazyderef (tl V2515) V2957) (if (cons? V2517) (let V2518 (shen.lazyderef (hd V2517) V2957) (if (cons? V2518) (let V2519 (shen.lazyderef (hd V2518) V2957) (if (cons? V2519) (let V2520 (shen.lazyderef (hd V2519) V2957) (if (= fail-if V2520) (let V2521 (shen.lazyderef (tl V2519) V2957) (if (cons? V2521) (let F (hd V2521) (let V2522 (shen.lazyderef (tl V2521) V2957) (if (= () V2522) (let V2523 (shen.lazyderef (tl V2518) V2957) (if (cons? V2523) (let Action (hd V2523) (let V2524 (shen.lazyderef (tl V2523) V2957) (if (= () V2524) (let V2525 (shen.lazyderef (tl V2517) V2957) (if (= () V2525) (do (shen.incinfs) (cut Throwcontrol V2957 (freeze (shen.t*-action (cons where (cons (cons not (cons (cons F (cons Action ())) ())) (cons Action ()))) V2955 V2956 V2957 V2958)))) false)) false))) false)) false))) false)) false)) false)) false)) false)) false)) false)) (if (= Case false) (let Case (let V2526 (shen.lazyderef V2954 V2957) (if (cons? V2526) (let V2527 (shen.lazyderef (hd V2526) V2957) (if (= shen.choicepoint! V2527) (let V2528 (shen.lazyderef (tl V2526) V2957) (if (cons? V2528) (let Action (hd V2528) (let V2529 (shen.lazyderef (tl V2528) V2957) (if (= () V2529) (do (shen.incinfs) (cut Throwcontrol V2957 (freeze (shen.t*-action (cons where (cons (cons not (cons (cons (cons = (cons Action ())) (cons (cons fail ()) ())) ())) (cons Action ()))) V2955 V2956 V2957 V2958)))) false))) false)) false)) false)) (if (= Case false) (do (shen.incinfs) (shen.t* (cons V2954 (cons : (cons V2955 ()))) V2956 V2957 V2958)) Case)) Case)) Case)))))

(defun shen.t*-pattern (V2959 V2960 V2961 V2962) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Hyp (shen.newpv V2961) (do (shen.incinfs) (shen.tms->hyp (shen.ues V2959) Hyp V2961 (freeze (cut Throwcontrol V2961 (freeze (shen.t* (cons V2959 (cons : (cons V2960 ()))) Hyp V2961 V2962))))))))))

(defun shen.tms->hyp (V2963 V2964 V2965 V2966) (let Case (let V2494 (shen.lazyderef V2963 V2965) (if (= () V2494) (let V2495 (shen.lazyderef V2964 V2965) (if (= () V2495) (do (shen.incinfs) (thaw V2966)) (if (shen.pvar? V2495) (do (shen.bindv V2495 () V2965) (let Result (do (shen.incinfs) (thaw V2966)) (do (shen.unbindv V2495 V2965) Result))) false))) false)) (if (= Case false) (let V2496 (shen.lazyderef V2963 V2965) (if (cons? V2496) (let Tm2491 (hd V2496) (let Tms (tl V2496) (let V2497 (shen.lazyderef V2964 V2965) (if (cons? V2497) (let V2498 (shen.lazyderef (hd V2497) V2965) (if (cons? V2498) (let Tm (hd V2498) (let V2499 (shen.lazyderef (tl V2498) V2965) (if (cons? V2499) (let V2500 (shen.lazyderef (hd V2499) V2965) (if (= : V2500) (let V2501 (shen.lazyderef (tl V2499) V2965) (if (cons? V2501) (let A (hd V2501) (let V2502 (shen.lazyderef (tl V2501) V2965) (if (= () V2502) (let Hyp (tl V2497) (do (shen.incinfs) (unify! Tm Tm2491 V2965 (freeze (shen.tms->hyp Tms Hyp V2965 V2966))))) (if (shen.pvar? V2502) (do (shen.bindv V2502 () V2965) (let Result (let Hyp (tl V2497) (do (shen.incinfs) (unify! Tm Tm2491 V2965 (freeze (shen.tms->hyp Tms Hyp V2965 V2966))))) (do (shen.unbindv V2502 V2965) Result))) false)))) (if (shen.pvar? V2501) (let A (shen.newpv V2965) (do (shen.bindv V2501 (cons A ()) V2965) (let Result (let Hyp (tl V2497) (do (shen.incinfs) (unify! Tm Tm2491 V2965 (freeze (shen.tms->hyp Tms Hyp V2965 V2966))))) (do (shen.unbindv V2501 V2965) Result)))) false))) (if (shen.pvar? V2500) (do (shen.bindv V2500 : V2965) (let Result (let V2503 (shen.lazyderef (tl V2499) V2965) (if (cons? V2503) (let A (hd V2503) (let V2504 (shen.lazyderef (tl V2503) V2965) (if (= () V2504) (let Hyp (tl V2497) (do (shen.incinfs) (unify! Tm Tm2491 V2965 (freeze (shen.tms->hyp Tms Hyp V2965 V2966))))) (if (shen.pvar? V2504) (do (shen.bindv V2504 () V2965) (let Result (let Hyp (tl V2497) (do (shen.incinfs) (unify! Tm Tm2491 V2965 (freeze (shen.tms->hyp Tms Hyp V2965 V2966))))) (do (shen.unbindv V2504 V2965) Result))) false)))) (if (shen.pvar? V2503) (let A (shen.newpv V2965) (do (shen.bindv V2503 (cons A ()) V2965) (let Result (let Hyp (tl V2497) (do (shen.incinfs) (unify! Tm Tm2491 V2965 (freeze (shen.tms->hyp Tms Hyp V2965 V2966))))) (do (shen.unbindv V2503 V2965) Result)))) false))) (do (shen.unbindv V2500 V2965) Result))) false))) (if (shen.pvar? V2499) (let A (shen.newpv V2965) (do (shen.bindv V2499 (cons : (cons A ())) V2965) (let Result (let Hyp (tl V2497) (do (shen.incinfs) (unify! Tm Tm2491 V2965 (freeze (shen.tms->hyp Tms Hyp V2965 V2966))))) (do (shen.unbindv V2499 V2965) Result)))) false)))) (if (shen.pvar? V2498) (let Tm (shen.newpv V2965) (let A (shen.newpv V2965) (do (shen.bindv V2498 (cons Tm (cons : (cons A ()))) V2965) (let Result (let Hyp (tl V2497) (do (shen.incinfs) (unify! Tm Tm2491 V2965 (freeze (shen.tms->hyp Tms Hyp V2965 V2966))))) (do (shen.unbindv V2498 V2965) Result))))) false))) (if (shen.pvar? V2497) (let Tm (shen.newpv V2965) (let A (shen.newpv V2965) (let Hyp (shen.newpv V2965) (do (shen.bindv V2497 (cons (cons Tm (cons : (cons A ()))) Hyp) V2965) (let Result (do (shen.incinfs) (unify! Tm Tm2491 V2965 (freeze (shen.tms->hyp Tms Hyp V2965 V2966)))) (do (shen.unbindv V2497 V2965) Result)))))) false))))) false)) Case)))

(defun findall (V2967 V2968 V2969 V2970 V2971) (let B (shen.newpv V2970) (let A (shen.newpv V2970) (do (shen.incinfs) (bind A (gensym shen.a) V2970 (freeze (bind B (set (shen.lazyderef A V2970) ()) V2970 (freeze (shen.findallhelp V2967 V2968 V2969 A V2970 V2971)))))))))

(defun shen.findallhelp (V2972 V2973 V2974 V2975 V2976 V2977) (let Case (do (shen.incinfs) (call V2973 V2976 (freeze (shen.remember V2975 V2972 V2976 (freeze (fwhen false V2976 V2977)))))) (if (= Case false) (do (shen.incinfs) (bind V2974 (value (shen.lazyderef V2975 V2976)) V2976 V2977)) Case)))

(defun shen.remember (V2978 V2979 V2980 V2981) (let B (shen.newpv V2980) (do (shen.incinfs) (bind B (set (shen.deref V2978 V2980) (cons (shen.deref V2979 V2980) (value (shen.deref V2978 V2980)))) V2980 V2981))))

(defun shen.t*-defcc (V2982 V2983 V2984 V2985 V2986) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let V2467 (shen.lazyderef V2982 V2985) (if (cons? V2467) (let V2468 (shen.lazyderef (hd V2467) V2985) (if (= defcc V2468) (let V2469 (shen.lazyderef (tl V2467) V2985) (if (cons? V2469) (let F (hd V2469) (let V2470 (shen.lazyderef (tl V2469) V2985) (if (cons? V2470) (let V2471 (shen.lazyderef (hd V2470) V2985) (if (= { V2471) (let V2472 (shen.lazyderef (tl V2470) V2985) (if (cons? V2472) (let V2473 (shen.lazyderef (hd V2472) V2985) (if (cons? V2473) (let V2474 (shen.lazyderef (hd V2473) V2985) (if (= list V2474) (let V2475 (shen.lazyderef (tl V2473) V2985) (if (cons? V2475) (let A (hd V2475) (let V2476 (shen.lazyderef (tl V2475) V2985) (if (= () V2476) (let V2477 (shen.lazyderef (tl V2472) V2985) (if (cons? V2477) (let V2478 (shen.lazyderef (hd V2477) V2985) (if (= ==> V2478) (let V2479 (shen.lazyderef (tl V2477) V2985) (if (cons? V2479) (let B (hd V2479) (let V2480 (shen.lazyderef (tl V2479) V2985) (if (cons? V2480) (let V2481 (shen.lazyderef (hd V2480) V2985) (if (= } V2481) (let Rest (tl V2480) (let Rest& (shen.newpv V2985) (let Rest&& (shen.newpv V2985) (let Rules (shen.newpv V2985) (let ListA&& (shen.newpv V2985) (let B&& (shen.newpv V2985) (let Sig (shen.newpv V2985) (let Declare (shen.newpv V2985) (do (shen.incinfs) (bind Sig (shen.ue (cons (cons list (cons (shen.lazyderef A V2985) ())) (cons ==> (cons (shen.lazyderef B V2985) ())))) V2985 (freeze (bind ListA&& (hd (shen.lazyderef Sig V2985)) V2985 (freeze (bind B&& (hd (tl (tl (shen.lazyderef Sig V2985)))) V2985 (freeze (bind Rest& (shen.plug-wildcards (shen.lazyderef Rest V2985)) V2985 (freeze (bind Rest&& (shen.ue (shen.lazyderef Rest& V2985)) V2985 (freeze (shen.get-rules Rules Rest&& V2985 (freeze (cut Throwcontrol V2985 (freeze (shen.tc-rules F Rules ListA&& B&& (cons (cons F (cons : (cons Sig ()))) V2984) 1 V2985 (freeze (unify V2983 (cons (cons list (cons A ())) (cons ==> (cons B ()))) V2985 (freeze (bind Declare (declare (shen.lazyderef F V2985) (cons (cons list (cons (shen.lazyderef A V2985) ())) (cons ==> (cons (shen.lazyderef B V2985) ())))) V2985 V2986)))))))))))))))))))))))))))) false)) false))) false)) false)) false)) false))) false)) false)) false)) false)) false)) false))) false)) false)) false)))))

(defun shen.plug-wildcards (V2987) (cond ((cons? V2987) (map shen.plug-wildcards V2987)) ((= V2987 _) (gensym (intern "X"))) (true V2987)))

(defun shen.get-rules (V2988 V2989 V2990 V2991) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (let V2460 (shen.lazyderef V2988 V2990) (if (= () V2460) (let V2461 (shen.lazyderef V2989 V2990) (if (= () V2461) (do (shen.incinfs) (cut Throwcontrol V2990 V2991)) false)) (if (shen.pvar? V2460) (do (shen.bindv V2460 () V2990) (let Result (let V2462 (shen.lazyderef V2989 V2990) (if (= () V2462) (do (shen.incinfs) (cut Throwcontrol V2990 V2991)) false)) (do (shen.unbindv V2460 V2990) Result))) false))) (if (= Case false) (let V2463 (shen.lazyderef V2988 V2990) (if (cons? V2463) (let Rule (hd V2463) (let Rules (tl V2463) (let Other (shen.newpv V2990) (do (shen.incinfs) (shen.first-rule V2989 Rule Other V2990 (freeze (cut Throwcontrol V2990 (freeze (shen.get-rules Rules Other V2990 V2991))))))))) (if (shen.pvar? V2463) (let Rule (shen.newpv V2990) (let Rules (shen.newpv V2990) (do (shen.bindv V2463 (cons Rule Rules) V2990) (let Result (let Other (shen.newpv V2990) (do (shen.incinfs) (shen.first-rule V2989 Rule Other V2990 (freeze (cut Throwcontrol V2990 (freeze (shen.get-rules Rules Other V2990 V2991))))))) (do (shen.unbindv V2463 V2990) Result))))) false))) Case)))))

(defun shen.first-rule (V2992 V2993 V2994 V2995 V2996) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (let V2453 (shen.lazyderef V2992 V2995) (if (cons? V2453) (let V2454 (shen.lazyderef (hd V2453) V2995) (if (= ; V2454) (let Other2448 (tl V2453) (let V2455 (shen.lazyderef V2993 V2995) (if (= () V2455) (do (shen.incinfs) (unify! V2994 Other2448 V2995 (freeze (cut Throwcontrol V2995 V2996)))) (if (shen.pvar? V2455) (do (shen.bindv V2455 () V2995) (let Result (do (shen.incinfs) (unify! V2994 Other2448 V2995 (freeze (cut Throwcontrol V2995 V2996)))) (do (shen.unbindv V2455 V2995) Result))) false)))) false)) false)) (if (= Case false) (let V2456 (shen.lazyderef V2992 V2995) (if (cons? V2456) (let X2449 (hd V2456) (let Rest (tl V2456) (let V2457 (shen.lazyderef V2993 V2995) (if (cons? V2457) (let X (hd V2457) (let Rule (tl V2457) (do (shen.incinfs) (unify! X X2449 V2995 (freeze (shen.first-rule Rest Rule V2994 V2995 V2996)))))) (if (shen.pvar? V2457) (let X (shen.newpv V2995) (let Rule (shen.newpv V2995) (do (shen.bindv V2457 (cons X Rule) V2995) (let Result (do (shen.incinfs) (unify! X X2449 V2995 (freeze (shen.first-rule Rest Rule V2994 V2995 V2996)))) (do (shen.unbindv V2457 V2995) Result))))) false))))) false)) Case)))))

(defun shen.tc-rules (V2997 V2998 V2999 V3000 V3001 V3002 V3003 V3004) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (let V2442 (shen.lazyderef V2998 V3003) (if (= () V2442) (do (shen.incinfs) (thaw V3004)) false)) (if (= Case false) (let V2443 (shen.lazyderef V2998 V3003) (if (cons? V2443) (let Rule (hd V2443) (let Rules (tl V2443) (let V2444 (shen.lazyderef V2999 V3003) (if (cons? V2444) (let V2445 (shen.lazyderef (hd V2444) V3003) (if (= list V2445) (let V2446 (shen.lazyderef (tl V2444) V3003) (if (cons? V2446) (let A (hd V2446) (let V2447 (shen.lazyderef (tl V2446) V3003) (if (= () V2447) (let M (shen.newpv V3003) (do (shen.incinfs) (shen.tc-rule V2997 Rule A V3000 V3001 V3002 V3003 (freeze (bind M (+ (shen.deref V3002 V3003) 1) V3003 (freeze (cut Throwcontrol V3003 (freeze (shen.tc-rules V2997 Rules (cons list (cons A ())) V3000 V3001 M V3003 V3004))))))))) false))) false)) false)) false)))) false)) Case)))))

(defun shen.tc-rule (V3005 V3006 V3007 V3008 V3009 V3010 V3011 V3012) (let Case (do (shen.incinfs) (shen.check-defcc-rule V3006 V3007 V3008 V3009 V3011 V3012)) (if (= Case false) (let Err (shen.newpv V3011) (do (shen.incinfs) (bind Err (simple-error (cn "type error in rule " (shen.app (shen.lazyderef V3010 V3011) (cn " of " (shen.app (shen.lazyderef V3005 V3011) "" shen.a)) shen.a))) V3011 V3012))) Case)))

(defun shen.check-defcc-rule (V3013 V3014 V3015 V3016 V3017 V3018) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Syntax (shen.newpv V3017) (let Semantics (shen.newpv V3017) (let SynHyps (shen.newpv V3017) (do (shen.incinfs) (shen.get-syntax+semantics Syntax Semantics V3013 V3017 (freeze (cut Throwcontrol V3017 (freeze (shen.syntax-hyps Syntax V3016 SynHyps V3014 V3017 (freeze (cut Throwcontrol V3017 (freeze (shen.syntax-check Syntax V3014 SynHyps V3017 (freeze (cut Throwcontrol V3017 (freeze (shen.semantics-check Semantics V3015 SynHyps V3017 V3018))))))))))))))))))))

(defun shen.syntax-hyps (V3019 V3020 V3021 V3022 V3023 V3024) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (let V2415 (shen.lazyderef V3019 V3023) (if (= () V2415) (do (shen.incinfs) (unify! V3021 V3020 V3023 V3024)) false)) (if (= Case false) (let Case (let V2416 (shen.lazyderef V3019 V3023) (if (cons? V2416) (let X2409 (hd V2416) (let Y (tl V2416) (let V2417 (shen.lazyderef V3021 V3023) (if (cons? V2417) (let V2418 (shen.lazyderef (hd V2417) V3023) (if (cons? V2418) (let X (hd V2418) (let V2419 (shen.lazyderef (tl V2418) V3023) (if (cons? V2419) (let V2420 (shen.lazyderef (hd V2419) V3023) (if (= : V2420) (let V2421 (shen.lazyderef (tl V2419) V3023) (if (cons? V2421) (let A2410 (hd V2421) (let V2422 (shen.lazyderef (tl V2421) V3023) (if (= () V2422) (let SynHyps (tl V2417) (do (shen.incinfs) (unify! V3022 A2410 V3023 (freeze (unify! X X2409 V3023 (freeze (fwhen (shen.ue? (shen.deref X V3023)) V3023 (freeze (cut Throwcontrol V3023 (freeze (shen.syntax-hyps Y V3020 SynHyps V3022 V3023 V3024))))))))))) (if (shen.pvar? V2422) (do (shen.bindv V2422 () V3023) (let Result (let SynHyps (tl V2417) (do (shen.incinfs) (unify! V3022 A2410 V3023 (freeze (unify! X X2409 V3023 (freeze (fwhen (shen.ue? (shen.deref X V3023)) V3023 (freeze (cut Throwcontrol V3023 (freeze (shen.syntax-hyps Y V3020 SynHyps V3022 V3023 V3024))))))))))) (do (shen.unbindv V2422 V3023) Result))) false)))) (if (shen.pvar? V2421) (let A2410 (shen.newpv V3023) (do (shen.bindv V2421 (cons A2410 ()) V3023) (let Result (let SynHyps (tl V2417) (do (shen.incinfs) (unify! V3022 A2410 V3023 (freeze (unify! X X2409 V3023 (freeze (fwhen (shen.ue? (shen.deref X V3023)) V3023 (freeze (cut Throwcontrol V3023 (freeze (shen.syntax-hyps Y V3020 SynHyps V3022 V3023 V3024))))))))))) (do (shen.unbindv V2421 V3023) Result)))) false))) (if (shen.pvar? V2420) (do (shen.bindv V2420 : V3023) (let Result (let V2423 (shen.lazyderef (tl V2419) V3023) (if (cons? V2423) (let A2410 (hd V2423) (let V2424 (shen.lazyderef (tl V2423) V3023) (if (= () V2424) (let SynHyps (tl V2417) (do (shen.incinfs) (unify! V3022 A2410 V3023 (freeze (unify! X X2409 V3023 (freeze (fwhen (shen.ue? (shen.deref X V3023)) V3023 (freeze (cut Throwcontrol V3023 (freeze (shen.syntax-hyps Y V3020 SynHyps V3022 V3023 V3024))))))))))) (if (shen.pvar? V2424) (do (shen.bindv V2424 () V3023) (let Result (let SynHyps (tl V2417) (do (shen.incinfs) (unify! V3022 A2410 V3023 (freeze (unify! X X2409 V3023 (freeze (fwhen (shen.ue? (shen.deref X V3023)) V3023 (freeze (cut Throwcontrol V3023 (freeze (shen.syntax-hyps Y V3020 SynHyps V3022 V3023 V3024))))))))))) (do (shen.unbindv V2424 V3023) Result))) false)))) (if (shen.pvar? V2423) (let A2410 (shen.newpv V3023) (do (shen.bindv V2423 (cons A2410 ()) V3023) (let Result (let SynHyps (tl V2417) (do (shen.incinfs) (unify! V3022 A2410 V3023 (freeze (unify! X X2409 V3023 (freeze (fwhen (shen.ue? (shen.deref X V3023)) V3023 (freeze (cut Throwcontrol V3023 (freeze (shen.syntax-hyps Y V3020 SynHyps V3022 V3023 V3024))))))))))) (do (shen.unbindv V2423 V3023) Result)))) false))) (do (shen.unbindv V2420 V3023) Result))) false))) (if (shen.pvar? V2419) (let A2410 (shen.newpv V3023) (do (shen.bindv V2419 (cons : (cons A2410 ())) V3023) (let Result (let SynHyps (tl V2417) (do (shen.incinfs) (unify! V3022 A2410 V3023 (freeze (unify! X X2409 V3023 (freeze (fwhen (shen.ue? (shen.deref X V3023)) V3023 (freeze (cut Throwcontrol V3023 (freeze (shen.syntax-hyps Y V3020 SynHyps V3022 V3023 V3024))))))))))) (do (shen.unbindv V2419 V3023) Result)))) false)))) (if (shen.pvar? V2418) (let X (shen.newpv V3023) (let A2410 (shen.newpv V3023) (do (shen.bindv V2418 (cons X (cons : (cons A2410 ()))) V3023) (let Result (let SynHyps (tl V2417) (do (shen.incinfs) (unify! V3022 A2410 V3023 (freeze (unify! X X2409 V3023 (freeze (fwhen (shen.ue? (shen.deref X V3023)) V3023 (freeze (cut Throwcontrol V3023 (freeze (shen.syntax-hyps Y V3020 SynHyps V3022 V3023 V3024))))))))))) (do (shen.unbindv V2418 V3023) Result))))) false))) (if (shen.pvar? V2417) (let X (shen.newpv V3023) (let A2410 (shen.newpv V3023) (let SynHyps (shen.newpv V3023) (do (shen.bindv V2417 (cons (cons X (cons : (cons A2410 ()))) SynHyps) V3023) (let Result (do (shen.incinfs) (unify! V3022 A2410 V3023 (freeze (unify! X X2409 V3023 (freeze (fwhen (shen.ue? (shen.deref X V3023)) V3023 (freeze (cut Throwcontrol V3023 (freeze (shen.syntax-hyps Y V3020 SynHyps V3022 V3023 V3024)))))))))) (do (shen.unbindv V2417 V3023) Result)))))) false))))) false)) (if (= Case false) (let V2425 (shen.lazyderef V3019 V3023) (if (cons? V2425) (let Y (tl V2425) (do (shen.incinfs) (shen.syntax-hyps Y V3020 V3021 V3022 V3023 V3024))) false)) Case)) Case)))))

(defun shen.get-syntax+semantics (V3025 V3026 V3027 V3028 V3029) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (let V2381 (shen.lazyderef V3025 V3028) (if (= () V2381) (let V2382 (shen.lazyderef V3027 V3028) (if (cons? V2382) (let V2383 (shen.lazyderef (hd V2382) V3028) (if (= := V2383) (let V2384 (shen.lazyderef (tl V2382) V3028) (if (cons? V2384) (let Semantics (hd V2384) (let V2385 (shen.lazyderef (tl V2384) V3028) (if (= () V2385) (do (shen.incinfs) (cut Throwcontrol V3028 (freeze (bind V3026 (shen.lazyderef Semantics V3028) V3028 V3029)))) false))) false)) false)) false)) (if (shen.pvar? V2381) (do (shen.bindv V2381 () V3028) (let Result (let V2386 (shen.lazyderef V3027 V3028) (if (cons? V2386) (let V2387 (shen.lazyderef (hd V2386) V3028) (if (= := V2387) (let V2388 (shen.lazyderef (tl V2386) V3028) (if (cons? V2388) (let Semantics (hd V2388) (let V2389 (shen.lazyderef (tl V2388) V3028) (if (= () V2389) (do (shen.incinfs) (cut Throwcontrol V3028 (freeze (bind V3026 (shen.lazyderef Semantics V3028) V3028 V3029)))) false))) false)) false)) false)) (do (shen.unbindv V2381 V3028) Result))) false))) (if (= Case false) (let Case (let V2390 (shen.lazyderef V3025 V3028) (if (= () V2390) (let V2391 (shen.lazyderef V3027 V3028) (if (cons? V2391) (let V2392 (shen.lazyderef (hd V2391) V3028) (if (= := V2392) (let V2393 (shen.lazyderef (tl V2391) V3028) (if (cons? V2393) (let Semantics (hd V2393) (let V2394 (shen.lazyderef (tl V2393) V3028) (if (cons? V2394) (let V2395 (shen.lazyderef (hd V2394) V3028) (if (= where V2395) (let V2396 (shen.lazyderef (tl V2394) V3028) (if (cons? V2396) (let G (hd V2396) (let V2397 (shen.lazyderef (tl V2396) V3028) (if (= () V2397) (do (shen.incinfs) (cut Throwcontrol V3028 (freeze (bind V3026 (cons where (cons (shen.lazyderef G V3028) (cons (shen.lazyderef Semantics V3028) ()))) V3028 V3029)))) false))) false)) false)) false))) false)) false)) false)) (if (shen.pvar? V2390) (do (shen.bindv V2390 () V3028) (let Result (let V2398 (shen.lazyderef V3027 V3028) (if (cons? V2398) (let V2399 (shen.lazyderef (hd V2398) V3028) (if (= := V2399) (let V2400 (shen.lazyderef (tl V2398) V3028) (if (cons? V2400) (let Semantics (hd V2400) (let V2401 (shen.lazyderef (tl V2400) V3028) (if (cons? V2401) (let V2402 (shen.lazyderef (hd V2401) V3028) (if (= where V2402) (let V2403 (shen.lazyderef (tl V2401) V3028) (if (cons? V2403) (let G (hd V2403) (let V2404 (shen.lazyderef (tl V2403) V3028) (if (= () V2404) (do (shen.incinfs) (cut Throwcontrol V3028 (freeze (bind V3026 (cons where (cons (shen.lazyderef G V3028) (cons (shen.lazyderef Semantics V3028) ()))) V3028 V3029)))) false))) false)) false)) false))) false)) false)) false)) (do (shen.unbindv V2390 V3028) Result))) false))) (if (= Case false) (let V2405 (shen.lazyderef V3025 V3028) (if (cons? V2405) (let X2377 (hd V2405) (let Syntax (tl V2405) (let V2406 (shen.lazyderef V3027 V3028) (if (cons? V2406) (let X (hd V2406) (let Rule (tl V2406) (do (shen.incinfs) (unify! X X2377 V3028 (freeze (shen.get-syntax+semantics Syntax V3026 Rule V3028 V3029)))))) false)))) (if (shen.pvar? V2405) (let X2377 (shen.newpv V3028) (let Syntax (shen.newpv V3028) (do (shen.bindv V2405 (cons X2377 Syntax) V3028) (let Result (let V2407 (shen.lazyderef V3027 V3028) (if (cons? V2407) (let X (hd V2407) (let Rule (tl V2407) (do (shen.incinfs) (unify! X X2377 V3028 (freeze (shen.get-syntax+semantics Syntax V3026 Rule V3028 V3029)))))) false)) (do (shen.unbindv V2405 V3028) Result))))) false))) Case)) Case)))))

(defun shen.syntax-check (V3030 V3031 V3032 V3033 V3034) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (let V2374 (shen.lazyderef V3030 V3033) (if (= () V2374) (do (shen.incinfs) (thaw V3034)) false)) (if (= Case false) (let Case (let V2375 (shen.lazyderef V3030 V3033) (if (cons? V2375) (let X (hd V2375) (let Syntax (tl V2375) (let C (shen.newpv V3033) (let X&& (shen.newpv V3033) (let B (shen.newpv V3033) (do (shen.incinfs) (fwhen (shen.grammar_symbol? (shen.lazyderef X V3033)) V3033 (freeze (cut Throwcontrol V3033 (freeze (shen.t* (cons X (cons : (cons (cons (cons list (cons B ())) (cons ==> (cons C ()))) ()))) V3032 V3033 (freeze (cut Throwcontrol V3033 (freeze (bind X&& (concat && (shen.lazyderef X V3033)) V3033 (freeze (cut Throwcontrol V3033 (freeze (shen.t* (cons X&& (cons : (cons (cons list (cons V3031 ())) ()))) (cons (cons X&& (cons : (cons (cons list (cons B ())) ()))) V3032) V3033 (freeze (cut Throwcontrol V3033 (freeze (shen.syntax-check Syntax V3031 V3032 V3033 V3034))))))))))))))))))))))) false)) (if (= Case false) (let V2376 (shen.lazyderef V3030 V3033) (if (cons? V2376) (let X (hd V2376) (let Syntax (tl V2376) (do (shen.incinfs) (shen.t* (cons X (cons : (cons V3031 ()))) V3032 V3033 (freeze (cut Throwcontrol V3033 (freeze (shen.syntax-check Syntax V3031 V3032 V3033 V3034)))))))) false)) Case)) Case)))))

(defun shen.semantics-check (V3035 V3036 V3037 V3038 V3039) (let Semantics* (shen.newpv V3038) (do (shen.incinfs) (bind Semantics* (shen.curry (shen.rename-semantics (shen.deref V3035 V3038))) V3038 (freeze (shen.t* (cons Semantics* (cons : (cons V3036 ()))) V3037 V3038 V3039))))))

(defun shen.rename-semantics (V3040) (cond ((cons? V3040) (cons (shen.rename-semantics (hd V3040)) (shen.rename-semantics (tl V3040)))) ((shen.grammar_symbol? V3040) (cons shen.<-sem (cons V3040 ()))) (true V3040)))



